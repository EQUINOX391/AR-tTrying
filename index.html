<!DOCTYPE html>
<html lang="id">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>3D Model Viewer AR - OLEH FADHILLAH SUKMA ARINI</title>
    <!-- Gunakan font modern -->
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      /* RESET & GLOBALS */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: 'Inter', sans-serif;
        background: linear-gradient(135deg, #1f1f1f, #323232);
        color: #fff;
        overflow: hidden;
        height: 100vh;
        position: relative;
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }
      a {
        color: inherit;
        text-decoration: none;
      }

      /* LOADING ANIMATION OVERLAY */
      #loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #111;
        z-index: 2000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      #loading-overlay .logo {
        font-size: 2.5em;
        font-weight: 600;
        letter-spacing: 2px;
        margin-bottom: 20px;
        /* Rounded rectangle background */
        background: #4caf50;
        color: #fff;
        padding: 10px 20px;
        border-radius: 10px;
      }
      #loading-overlay .version {
        margin-top: 10px;
        font-size: 1em;
        opacity: 0.8;
      }
      #loading-overlay .spinner {
        border: 6px solid rgba(255, 255, 255, 0.2);
        border-top: 6px solid #4caf50;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
        margin-top: 20px;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      /* Hide loading overlay after animation */
      .loaded #loading-overlay {
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.5s ease-out;
      }

      /* Responsive icons & buttons */
      .icon-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #4caf50;
        color: #fff;
        border: none;
        border-radius: 12px;
        cursor: pointer;
        padding: 10px 15px;
        font-size: 1em;
        transition: background-color 0.3s ease, transform 0.2s;
      }
      .icon-btn:hover {
        background-color: #45a049;
        transform: scale(1.03);
      }
      
      /* AR Button - Rounded Rectangle style */
      #ar-button-container {
        position: absolute;
        top: 20px;
        right: 20px;
        z-index: 1000;
      }
      #arButton {
        background-color: #4caf50;
        color: #fff;
        border: none;
        border-radius: 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 60px;
        height: 60px;
        font-size: 1em;
        font-weight: 600;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        transition: background-color 0.3s ease, transform 0.2s;
      }
      #arButton:hover {
        background-color: #45a049;
        transform: scale(1.05);
      }
      #arButton.ar-active {
        background-color: #f44336;
      }
      #arButton.ar-active:hover {
        background-color: #d32f2f;
      }

      /* Loading indicator (fallback for non animated loading) */
      #loading-indicator {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 1.3em;
        background-color: rgba(0, 0, 0, 0.8);
        padding: 20px 30px;
        border-radius: 8px;
        text-align: center;
        z-index: 1100;
        display: none;
      }

      /* Preset buttons container */
      #preset-buttons-container {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        z-index: 1000;
        padding: 10px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 10px;
      }
      .preset-button {
        background-color: #333;
        border: none;
        padding: 10px 15px;
        border-radius: 12px;
        cursor: pointer;
        font-size: 0.9em;
        transition: background-color 0.2s, transform 0.2s;
      }
      .preset-button:hover {
        background-color: #555;
        transform: scale(1.03);
      }
      .preset-button:active {
        background-color: #222;
      }

      /* lil-gui style overrides */
      .lil-gui.autoPlace {
        top: 20px;
        left: 20px;
        max-height: calc(100vh - 40px);
        overflow-y: auto;
        z-index: 1000;
      }

      /* Reticle styling untuk AR */
      #reticle {
        position: absolute;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        border: 3px solid rgba(255, 255, 255, 0.8);
        box-shadow: 0 0 12px rgba(255, 255, 255, 0.6);
        box-sizing: border-box;
        display: none;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 990;
      }

      /* AR instructions panel */
      #ar-instructions {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0, 0, 0, 0.85);
        color: #fff;
        padding: 20px 25px;
        border-radius: 10px;
        text-align: center;
        z-index: 1200;
        display: none;
        font-size: 1.1em;
        line-height: 1.4;
      }
      #ar-instructions button {
        background-color: #4caf50;
        color: #fff;
        border: none;
        padding: 10px 20px;
        border-radius: 12px;
        cursor: pointer;
        margin-top: 15px;
        font-size: 1em;
        transition: background-color 0.3s;
      }
      #ar-instructions button:hover {
        background-color: #45a049;
      }

      /* On-screen log */
      #on-screen-log-container {
        position: absolute;
        bottom: 20px;
        left: 20px;
        width: 300px;
        max-height: 150px;
        background-color: rgba(0, 0, 0, 0.6);
        color: #0f0;
        font-family: monospace;
        font-size: 0.8em;
        padding: 8px;
        border-radius: 6px;
        overflow-y: auto;
        z-index: 1000;
        display: none;
      }

      /* App version display */
      #app-version {
        position: absolute;
        bottom: 20px;
        right: 20px;
        font-size: 0.75em;
        color: rgba(255, 255, 255, 0.7);
        z-index: 1001;
        display: none;
      }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
          "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.js"
        }
      }
    </script>
  </head>
  <body>
    <!-- LOADING OVERLAY WITH ANIMATION (10 seconds or custom) -->
    <div id="loading-overlay">
      <div class="logo">OLEH FADHILLAH SUKMA ARINI</div>
      <div class="spinner"></div>
      <div class="version">Version 0.0.5</div>
    </div>

    <!-- Loading indicator fallback -->
    <div id="loading-indicator">Memuat Model...</div>

    <!-- Preset buttons container -->
    <div id="preset-buttons-container">
      <button class="preset-button" data-view="Default">Default</button>
      <button class="preset-button" data-view="Front">Front</button>
      <button class="preset-button" data-view="Back">Back</button>
      <button class="preset-button" data-view="Top">Top</button>
      <button class="preset-button" data-view="Bottom">Bottom</button>
      <button class="preset-button" data-view="Left">Left</button>
      <button class="preset-button" data-view="Right">Right</button>
    </div>

    <!-- AR button container -->
    <div id="ar-button-container">
      <button id="arButton" class="icon-btn">AR</button>
    </div>

    <!-- AR instructions panel -->
    <div id="ar-instructions">
      <p>Arahkan kamera ke permukaan datar (lantai/meja).</p>
      <button id="start-scan-button" class="icon-btn">Mulai Pindai</button>
    </div>

    <!-- Reticle untuk AR -->
    <div id="reticle"></div>

    <!-- On-screen Log -->
    <div id="on-screen-log-container"></div>

    <!-- App Version Display -->
    <div id="app-version">APP VERSI 0.0.5</div>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
      import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
      import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
      import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
      import GUI from 'lil-gui';

      let scene, camera, renderer, controls, composer, gui;
      let model, modelContainerGroup, ambientLight, directionalLight;
      let clock;
      const loadingIndicator = document.getElementById('loading-indicator');
      const arInstructionsPanel = document.getElementById('ar-instructions');
      const startScanButton = document.getElementById('start-scan-button');
      const onScreenLogContainer = document.getElementById('on-screen-log-container');
      const appVersionDisplay = document.getElementById('app-version');

      let skyboxObject = null;
      const modelCenter = new THREE.Vector3();
      const modelSize = new THREE.Vector3();

      let xrSession = null;
      let xrRefSpace = null;
      let xrHitTestSource = null;
      let reticleMesh;
      let modelPlaced = false;

      let isUpdatingViewPresetGUI = false;

      const APP_VERSION = "0.0.5";

      // AR interaction state
      let arIsPinching = false;
      let arInitialPinchDistance = 0;
      let arIsDragging = false;
      let arLastDragX = 0;
      let arLastDragY = 0;
      const arDragSensitivity = 0.005;

      const params = {
        modelPath: 'Cupang.glb',
        skyboxGlbUrl: 'inside_galaxy_skybox_hdri_360_panorama.glb',
        toneMappingExposure: 1.0,
        ambientLightIntensity: 3.0,
        directionalLightIntensity: 4.0,
        directionalLightColor: 0xffffff,
        initialRotationX_deg: 0.0,
        initialRotationY_deg: 0.0,
        initialRotationZ_deg: 0.0,
        animateModel: false,
        rotationSpeed: 0.1,
        selectedViewPreset: 'Default',
        cameraFOV: 50,
        modelScale: 1.0,
        arModelScale: 0.5,
        skyboxBrightness: 1.0,
        backgroundColor: '#4682B4',
        showSkybox: true,
      };

      function logToScreen(message, type = 'info') {
        if (onScreenLogContainer) {
          const logEntry = document.createElement('div');
          const timestamp = new Date().toLocaleTimeString();
          logEntry.textContent = `[${timestamp}] ${message}`;
          if (type === 'error') logEntry.style.color = '#ff6666';
          else if (type === 'warn') logEntry.style.color = '#ffcc66';
          else logEntry.style.color = '#99ff99';
          onScreenLogContainer.appendChild(logEntry);
          onScreenLogContainer.scrollTop = onScreenLogContainer.scrollHeight;
        }
        if (type === 'error') console.error(message);
        else if (type === 'warn') console.warn(message);
        else console.log(message);
      }

      function init() {
        // Start loading animation for ~10 seconds
        setTimeout(() => {
          document.body.classList.add('loaded');
          // Remove overlay from DOM after fade-out
          setTimeout(() => {
            const loadingOverlay = document.getElementById('loading-overlay');
            if (loadingOverlay) loadingOverlay.parentNode.removeChild(loadingOverlay);
          }, 600);
        }, 10000);

        if (loadingIndicator) {
          loadingIndicator.style.display = 'block';
          loadingIndicator.textContent = 'Memuat Model...';
        }
        clock = new THREE.Clock();
        scene = new THREE.Scene();
        scene.background = new THREE.Color(params.backgroundColor);

        camera = new THREE.PerspectiveCamera(
          params.cameraFOV,
          window.innerWidth / window.innerHeight,
          0.01,
          10000
        );
        camera.position.set(0, 1.6, 3);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = params.toneMappingExposure;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 0.01;
        controls.maxDistance = 5000;
        controls.target.set(0, 0, 0);

        ambientLight = new THREE.AmbientLight(0xffffff, params.ambientLightIntensity);
        scene.add(ambientLight);

        directionalLight = new THREE.DirectionalLight(
          params.directionalLightColor,
          params.directionalLightIntensity
        );
        directionalLight.position.set(1, 1.5, 1).normalize();
        scene.add(directionalLight);

        modelContainerGroup = new THREE.Group();
        scene.add(modelContainerGroup);

        const arButtonElement = document.getElementById('arButton');
        if (navigator.xr) {
          navigator.xr
            .isSessionSupported('immersive-ar')
            .then((supported) => {
              arButtonElement.style.display = 'flex';
              if (supported) {
                arButtonElement.addEventListener('click', onARButtonClick);
                arButtonElement.disabled = false;
                arButtonElement.textContent = 'AR';
                logToScreen('AR didukung oleh perangkat/browser ini.');
              } else {
                arButtonElement.textContent = 'No AR';
                arButtonElement.disabled = true;
                logToScreen('AR tidak didukung oleh perangkat/browser ini.', 'warn');
              }
            })
            .catch((err) => {
              logToScreen(`Error saat memeriksa dukungan AR: ${err.message}`, 'error');
              arButtonElement.textContent = 'Err AR';
              arButtonElement.disabled = true;
              arButtonElement.style.display = 'flex';
            });
        } else {
          arButtonElement.style.display = 'flex';
          arButtonElement.textContent = 'No XR';
          arButtonElement.disabled = true;
          logToScreen('WebXR API tidak tersedia di browser ini.', 'warn');
        }

        reticleMesh = new THREE.Mesh(
          new THREE.RingGeometry(0.04, 0.055, 32).rotateX(-Math.PI / 2),
          new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            opacity: 0.8,
            transparent: true,
            depthTest: false,
          })
        );
        reticleMesh.matrixAutoUpdate = false;
        reticleMesh.visible = false;
        reticleMesh.renderOrder = 10;
        scene.add(reticleMesh);

        if (
          params.skyboxGlbUrl &&
          params.skyboxGlbUrl !== 'SKYBOX_ANDA.glb' &&
          !params.skyboxGlbUrl.includes('placehold.co')
        ) {
          loadSkyboxFromGLB();
        } else {
          logToScreen(
            'Path Skybox GLB tidak valid atau placeholder, skybox tidak akan dimuat secara otomatis.',
            'warn'
          );
        }
        updateBackgroundVisibility();
        loadMainModel();

        composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);
        const outputPass = new OutputPass();
        composer.addPass(outputPass);

        setupGUI();
        setupPresetButtons();
        startScanButton.addEventListener('click', onStartScanButtonClick);
        window.addEventListener('resize', onWindowResize, false);
        renderer.domElement.addEventListener('click', onSelectAR);
        renderer.setAnimationLoop(animate);
      }

      function onARButtonClick() {
        const arButtonElement = document.getElementById('arButton');
        if (!xrSession) {
          logToScreen('Mencoba memulai sesi AR...');
          navigator.xr
            .requestSession('immersive-ar', {
              requiredFeatures: ['hit-test', 'dom-overlay'],
              domOverlay: { root: document.body },
            })
            .then(onSessionStarted)
            .catch((err) => {
              logToScreen(`Gagal memulai sesi AR: ${err.message}`, 'error');
              logToScreen(
                'Gagal memulai sesi AR. Pastikan perangkat & browser mendukung, dan izin kamera diberikan. Cek konsol untuk detail.',
                'error'
              );
              arButtonElement.textContent = 'AR Fail';
            });
        } else {
          logToScreen('Mengakhiri sesi AR...');
          xrSession.end();
        }
      }

      function onSessionStarted(session) {
        logToScreen(`Sesi AR dimulai. ID Sesi: ${session}`);
        xrSession = session;
        const arButtonElement = document.getElementById('arButton');
        arButtonElement.textContent = 'Stop AR';
        arButtonElement.classList.add('ar-active');

        document.getElementById('preset-buttons-container').style.display = 'none';
        if (gui) gui.hide();
        if (skyboxObject) skyboxObject.visible = false;
        scene.background = null;

        xrRefSpace = null;
        xrHitTestSource = null;
        modelPlaced = false;
        if (modelContainerGroup) {
          modelContainerGroup.visible = false;
          modelContainerGroup.userData.originalScale = modelContainerGroup.scale.clone();
          modelContainerGroup.scale.set(params.arModelScale, params.arModelScale, params.arModelScale);
          modelContainerGroup.userData.initialArScale = params.arModelScale;
          logToScreen(`Model disembunyikan, skala AR diatur ke: ${params.arModelScale}`);
        }
        reticleMesh.visible = false;
        arInstructionsPanel.style.display = 'block';
        onScreenLogContainer.style.display = 'block';
        appVersionDisplay.style.display = 'block';
        appVersionDisplay.textContent = `APP VERSI ${APP_VERSION}`;

        session.addEventListener('end', onSessionEnded);

        renderer.xr.setReferenceSpaceType('local');
        renderer.xr
          .setSession(session)
          .then(() => {
            logToScreen('Sesi XR berhasil diset ke renderer.');
          })
          .catch((err) => {
            logToScreen(`Error saat set session ke renderer: ${err.message}`, 'error');
            session.end().catch((e) => logToScreen(`Error mengakhiri sesi setelah setSession gagal: ${e.message}`, 'error'));
          });
      }

      function onStartScanButtonClick() {
        logToScreen("Tombol 'Mulai Pindai Permukaan' ditekan.");
        arInstructionsPanel.style.display = 'none';
        if (xrSession && !xrHitTestSource) {
          xrSession
            .requestReferenceSpace('viewer')
            .then((refSpaceViewer) => {
              logToScreen('Viewer reference space didapatkan untuk hit-test.');
              return xrSession.requestHitTestSource({ space: refSpaceViewer });
            })
            .then((source) => {
              xrHitTestSource = source;
              reticleMesh.visible = true;
              logToScreen('Hit test source berhasil didapatkan. Reticle aktif.');
            })
            .catch((err) => {
              logToScreen(`Error mendapatkan hit test source: ${err.message}`, 'error');
              logToScreen('Tidak bisa memulai pemindaian permukaan. Coba lagi atau restart sesi AR.', 'error');
              reticleMesh.visible = false;
            });
        } else if (xrHitTestSource) {
          logToScreen('Hit test source sudah ada. Reticle seharusnya sudah aktif.');
          reticleMesh.visible = true;
        } else if (!xrSession) {
          logToScreen('Sesi AR tidak aktif saat mencoba memulai pemindaian.', 'warn');
        }
      }

      function onSessionEnded() {
        logToScreen('Sesi AR berakhir.');
        xrSession = null;
        const arButtonElement = document.getElementById('arButton');
        arButtonElement.textContent = 'AR';
        arButtonElement.classList.remove('ar-active');

        document.getElementById('preset-buttons-container').style.display = 'flex';
        if (gui) gui.show();
        arInstructionsPanel.style.display = 'none';
        onScreenLogContainer.style.display = 'none';
        appVersionDisplay.style.display = 'none';
        reticleMesh.visible = false;

        renderer.domElement.removeEventListener('touchstart', handleARtouchstart);
        renderer.domElement.removeEventListener('touchmove', handleARtouchmove);
        renderer.domElement.removeEventListener('touchend', handleARtouchend);
        arIsPinching = false;
        arIsDragging = false;
        logToScreen('Listener interaksi AR dihapus.');

        if (modelContainerGroup) {
          modelContainerGroup.visible = true;
          if (modelContainerGroup.userData.originalScale) {
            modelContainerGroup.scale.copy(modelContainerGroup.userData.originalScale);
            logToScreen(`Skala model dikembalikan ke non-AR: ${modelContainerGroup.scale.x.toFixed(2)}`);
          } else {
            modelContainerGroup.scale.set(params.modelScale, params.modelScale, params.modelScale);
          }
        }
        if (model) goToViewPreset(params.selectedViewPreset, true);
        updateBackgroundVisibility();
      }

      function onSelectAR(event) {
        logToScreen(
          `onSelectAR. Sesi AR: ${!!xrSession}, Reticle: ${reticleMesh.visible}, Model Ditempatkan: ${modelPlaced}`
        );
        if (xrSession && reticleMesh.visible && !modelPlaced) {
          if (modelContainerGroup && model) {
            logToScreen(
              'Mencoba menempatkan model. Matriks reticle:',
              reticleMesh.matrix.elements.map((n) => n.toFixed(2)).join(', ')
            );
            modelContainerGroup.matrix.copy(reticleMesh.matrix);
            modelContainerGroup.matrix.decompose(
              modelContainerGroup.position,
              modelContainerGroup.quaternion,
              modelContainerGroup.scale
            );
            modelContainerGroup.scale.set(params.arModelScale, params.arModelScale, params.arModelScale);
            modelContainerGroup.userData.initialArScale = params.arModelScale;
            modelContainerGroup.visible = true;
            modelPlaced = true;
            reticleMesh.visible = false;
            logToScreen(
              `Model AR ditempatkan. Pos: ${modelContainerGroup.position
                .toArray()
                .map((n) => n.toFixed(2))}, Skala: ${params.arModelScale}`
            );
            renderer.domElement.addEventListener('touchstart', handleARtouchstart, { passive: false });
            renderer.domElement.addEventListener('touchmove', handleARtouchmove, { passive: false });
            renderer.domElement.addEventListener('touchend', handleARtouchend, { passive: false });
            logToScreen('Listener interaksi AR (drag/pinch) ditambahkan.');
          } else {
            logToScreen('Model atau modelContainerGroup tidak siap untuk ditempatkan di AR.', 'warn');
          }
        } else {
          logToScreen('Kondisi untuk menempatkan model AR tidak terpenuhi (mungkin sudah ditempatkan atau reticle tidak terlihat).');
        }
      }

      // --- AR Interaction Functions ---
      function getDistanceBetweenTouches(touches) {
        const touch1 = touches[0];
        const touch2 = touches[1];
        return Math.sqrt(Math.pow(touch2.clientX - touch1.clientX, 2) + Math.pow(touch2.clientY - touch1.clientY, 2));
      }

      function handleARtouchstart(event) {
        if (!xrSession || !modelPlaced || !modelContainerGroup) return;
        event.preventDefault();
        const touches = event.touches;
        if (touches.length === 1) {
          arIsDragging = true;
          arIsPinching = false;
          arLastDragX = touches[0].clientX;
          arLastDragY = touches[0].clientY;
          logToScreen('AR Drag Start');
        } else if (touches.length === 2) {
          arIsPinching = true;
          arIsDragging = false;
          arInitialPinchDistance = getDistanceBetweenTouches(touches);
          modelContainerGroup.userData.currentPinchStartScale = modelContainerGroup.scale.x;
          logToScreen(
            `AR Pinch Start. Initial Distance: ${arInitialPinchDistance.toFixed(
              2
            )}, Start Scale: ${modelContainerGroup.userData.currentPinchStartScale.toFixed(3)}`
          );
        }
      }

      function handleARtouchmove(event) {
        if (!xrSession || !modelPlaced || !modelContainerGroup) return;
        event.preventDefault();
        const touches = event.touches;
        if (arIsDragging && touches.length === 1) {
          const deltaX = touches[0].clientX - arLastDragX;
          const deltaY = touches[0].clientY - arLastDragY;
          modelContainerGroup.rotation.y += deltaX * arDragSensitivity;
          modelContainerGroup.rotation.x += deltaY * arDragSensitivity;
          arLastDragX = touches[0].clientX;
          arLastDragY = touches[0].clientY;
        } else if (arIsPinching && touches.length === 2) {
          const currentPinchDistance = getDistanceBetweenTouches(touches);
          if (arInitialPinchDistance > 0 && modelContainerGroup.userData.currentPinchStartScale !== undefined) {
            const scaleFactor = currentPinchDistance / arInitialPinchDistance;
            let newScale = modelContainerGroup.userData.currentPinchStartScale * scaleFactor;
            const minScale = params.arModelScale * 0.1;
            const maxScale = params.arModelScale * 10;
            newScale = Math.max(minScale, Math.min(newScale, maxScale));
            modelContainerGroup.scale.set(newScale, newScale, newScale);
          }
        }
      }

      function handleARtouchend(event) {
        if (!xrSession || !modelPlaced) return;
        if (arIsDragging && event.touches.length < 1) {
          arIsDragging = false;
          logToScreen('AR Drag End');
        }
        if (arIsPinching && event.touches.length < 2) {
          arIsPinching = false;
          if (modelContainerGroup) {
            params.arModelScale = modelContainerGroup.scale.x;
            if (gui) {
              const arScaleController = gui.controllersRecursive().find((c) => c.property === 'arModelScale');
              if (arScaleController) arScaleController.setValue(params.arModelScale);
            }
          }
          logToScreen(`AR Pinch End. Final AR Scale: ${params.arModelScale.toFixed(3)}`);
        }
      }
      // --- End AR Interaction Functions ---

      function loadMainModel() {
        if (loadingIndicator) {
          loadingIndicator.style.display = 'block';
          loadingIndicator.textContent = 'Memuat Model...';
        }
        logToScreen(`Mulai memuat model dari: ${params.modelPath}`);
        if (model) {
          modelContainerGroup.remove(model);
          model.traverse((node) => {
            if (node.geometry) node.geometry.dispose();
            if (node.material) {
              if (Array.isArray(node.material)) node.material.forEach((mat) => mat.dispose());
              else node.material.dispose();
            }
          });
          model = null;
          logToScreen('Model lama dibersihkan.');
        }
        modelCenter.set(0, 0, 0);
        modelSize.set(0, 0, 0);
        modelContainerGroup.position.set(0, 0, 0);
        modelContainerGroup.rotation.set(0, 0, 0);
        modelContainerGroup.quaternion.identity();

        const mainModelLoader = new GLTFLoader();
        mainModelLoader.load(
          params.modelPath,
          function (gltf) {
            model = gltf.scene;
            if (!model) {
              logToScreen(`GLTFLoader berhasil, tetapi gltf.scene kosong atau tidak valid untuk path: ${params.modelPath}`, 'error');
              if (loadingIndicator) {
                loadingIndicator.innerHTML = `Gagal memproses model.<br>File "${params.modelPath}" mungkin tidak valid.`;
                loadingIndicator.style.color = 'red';
              }
              return;
            }
            logToScreen('Model GLTF berhasil di-parse.');
            modelContainerGroup.add(model);
            const box = new THREE.Box3().setFromObject(modelContainerGroup);
            box.getCenter(modelCenter);
            box.getSize(modelSize);
            logToScreen(
              `Ukuran model awal: X:${modelSize.x.toFixed(2)}, Y:${modelSize.y.toFixed(2)}, Z:${modelSize.z.toFixed(2)}`
            );
            modelContainerGroup.position.sub(modelCenter);
            modelCenter.set(0, 0, 0);
            logToScreen('ModelContainerGroup dipusatkan.');
            applyInitialRotation();
            applyModelScale();
            updateMaterialProperties();
            logToScreen('Model GLB utama berhasil dimuat dan disiapkan.');
            if (loadingIndicator) loadingIndicator.style.display = 'none';
          },
          function (xhr) {
            if (xhr.lengthComputable) {
              const percentComplete = (xhr.loaded / xhr.total) * 100;
              if (loadingIndicator) loadingIndicator.textContent = `Memuat Model: ${Math.round(percentComplete, 2)}%`;
            } else {
              if (loadingIndicator)
                loadingIndicator.textContent = `Memuat Model... (${(xhr.loaded / 1024 / 1024).toFixed(2)} MB)`;
            }
          },
          function (error) {
            logToScreen(`Gagal memuat model GLB utama dari path: ${params.modelPath}. Error: ${error.message || error}`, 'error');
            if (loadingIndicator) {
              loadingIndicator.innerHTML = `Gagal memuat model.<br>Pastikan file "${params.modelPath}" ada di direktori yang sama atau path URL benar. Cek konsol untuk detail error.`;
              loadingIndicator.style.color = 'red';
            }
          }
        );
      }

      function applyModelScale() {
        if (modelContainerGroup && model) {
          const scaleValue = xrSession ? params.arModelScale : params.modelScale;
          modelContainerGroup.scale.set(scaleValue, scaleValue, scaleValue);
          logToScreen(`Skala model diatur ke: ${scaleValue.toFixed(3)} (Sesi AR: ${!!xrSession})`);
          if (!xrSession) {
            const box = new THREE.Box3().setFromObject(modelContainerGroup);
            box.getSize(modelSize);
            goToViewPreset(params.selectedViewPreset, true);
          } else {
            modelContainerGroup.userData.initialArScale = scaleValue;
          }
        } else if (!model) {
          logToScreen('applyModelScale dipanggil tetapi model belum dimuat.', 'warn');
        }
      }

      function loadSkyboxFromGLB() {
        if (
          !params.skyboxGlbUrl ||
          params.skyboxGlbUrl === 'SKYBOX_ANDA.glb' ||
          params.skyboxGlbUrl.includes('placehold.co')
        ) {
          logToScreen('URL Skybox GLB tidak valid atau placeholder. Skybox tidak akan dimuat.', 'warn');
          if (skyboxObject) {
            scene.remove(skyboxObject);
            skyboxObject.traverse((node) => {
              if (node.geometry) node.geometry.dispose();
              if (node.material) {
                if (Array.isArray(node.material)) node.material.forEach((mat) => mat.dispose());
                else node.material.dispose();
              }
            });
            skyboxObject = null;
          }
          updateBackgroundVisibility();
          return;
        }
        logToScreen(`Mulai memuat skybox dari: ${params.skyboxGlbUrl}`);
        const loader = new GLTFLoader();
        loader.load(
          params.skyboxGlbUrl,
          (gltf) => {
            if (skyboxObject) {
              scene.remove(skyboxObject);
              skyboxObject.traverse((node) => {
                if (node.geometry) node.geometry.dispose();
                if (node.material) {
                  if (Array.isArray(node.material)) node.material.forEach((mat) => mat.dispose());
                  else node.material.dispose();
                }
              });
            }
            skyboxObject = gltf.scene;
            skyboxObject.traverse((node) => {
              if (node.isMesh) {
                const materials = Array.isArray(node.material) ? node.material : [node.material];
                materials.forEach((material) => {
                  material.side = THREE.BackSide;
                  if (material.isMeshStandardMaterial || material.isMeshPhysicalMaterial) {
                    if (material.userData.initialEmissiveIntensityGLB === undefined) {
                      material.userData.initialEmissiveIntensityGLB = material.emissiveIntensity;
                    }
                    material.emissiveIntensity = material.userData.initialEmissiveIntensityGLB * params.skyboxBrightness;
                    if (!material.emissiveMap) {
                      if (material.userData.initialEmissiveColorGLB === undefined) {
                        material.userData.initialEmissiveColorGLB = material.emissive.clone();
                      }
                      material.emissive.copy(material.userData.initialEmissiveColorGLB).multiplyScalar(
                        params.skyboxBrightness
                      );
                    }
                  } else if (material.isMeshBasicMaterial) {
                    if (material.userData.initialColorGLB === undefined) {
                      material.userData.initialColorGLB = material.color.clone();
                    }
                    material.color.copy(material.userData.initialColorGLB).multiplyScalar(params.skyboxBrightness);
                  }
                  material.needsUpdate = true;
                });
              }
            });
            const skyboxScale = Math.max(camera.far * 0.5, 1000);
            skyboxObject.scale.set(skyboxScale, skyboxScale, skyboxScale);
            skyboxObject.renderOrder = -10;
            scene.add(skyboxObject);
            updateBackgroundVisibility();
            logToScreen('Skybox GLB berhasil dimuat.');
          },
          undefined,
          (error) => {
            logToScreen(`Gagal memuat Skybox GLB dari path: ${params.skyboxGlbUrl}. Error: ${error.message || error}`, 'error');
            if (skyboxObject) {
              scene.remove(skyboxObject);
              skyboxObject = null;
            }
            updateBackgroundVisibility();
          }
        );
      }

      function updateBackgroundVisibility() {
        if (skyboxObject) {
          skyboxObject.visible = params.showSkybox && !xrSession;
        }
        if (params.showSkybox && skyboxObject && skyboxObject.children.length > 0 && !xrSession) {
          scene.background = null;
        } else if (!xrSession) {
          scene.background = new THREE.Color(params.backgroundColor);
        } else {
          scene.background = null;
        }
      }

      function applyInitialRotation() {
        if (modelContainerGroup) {
          modelContainerGroup.rotation.set(
            THREE.MathUtils.degToRad(params.initialRotationX_deg),
            THREE.MathUtils.degToRad(params.initialRotationY_deg),
            THREE.MathUtils.degToRad(params.initialRotationZ_deg)
          );
        }
      }

      function updateMaterialProperties() {
        if (!model) return;
        model.traverse((node) => {
          if (node.isMesh && node.material) {
            // Additional modifications to material if needed can be placed here.
          }
        });
      }

      // PRESET VIEW MAPPING (Modernized preset view)
      // "Front" => dari kiri, "Back" => dari kanan, "Left" => dari depan, "Right" => dari belakang.
      function goToViewPreset(presetName, instant = false) {
        if (isUpdatingViewPresetGUI) return;
        if (!modelContainerGroup || !camera || !controls || !model) {
          logToScreen('goToViewPreset: Komponen belum siap.', 'warn');
          return;
        }
        isUpdatingViewPresetGUI = true;
        const center = new THREE.Vector3(0, 0, 0);
        const currentBox = new THREE.Box3().setFromObject(modelContainerGroup);
        currentBox.getSize(modelSize);
        const maxDim = Math.max(modelSize.x, modelSize.y, modelSize.z, 0.1);
        const distanceFactor = 1.8;
        let distance = maxDim * distanceFactor;
        distance = Math.max(distance, 0.2);
        let newCamPos = new THREE.Vector3();
        camera.up.set(0, 1, 0);
        switch (presetName) {
          case 'Front':
            newCamPos.set(center.x - distance, center.y, center.z);
            break;
          case 'Back':
            newCamPos.set(center.x + distance, center.y, center.z);
            break;
          case 'Left':
            newCamPos.set(center.x, center.y, center.z + distance);
            break;
          case 'Right':
            newCamPos.set(center.x, center.y, center.z - distance);
            break;
          case 'Top':
            newCamPos.set(center.x, center.y + distance, center.z + 0.0001);
            camera.up.set(0, 0, -1);
            break;
          case 'Bottom':
            newCamPos.set(center.x, center.y - distance, center.z + 0.0001);
            camera.up.set(0, 0, 1);
            break;
          case 'Default':
          default:
            frameArea(modelContainerGroup, camera, controls, instant);
            params.selectedViewPreset = 'Default';
            if (gui) {
              const presetController = gui.controllersRecursive().find((c) => c.property === 'selectedViewPreset');
              if (presetController && presetController.getValue() !== 'Default') {
                presetController.setValue('Default');
              } else if (presetController) {
                presetController.updateDisplay();
              }
            }
            isUpdatingViewPresetGUI = false;
            return;
        }
        if (instant) {
          camera.position.copy(newCamPos);
          controls.target.copy(center);
          camera.lookAt(center);
          controls.update();
        } else {
          camera.position.copy(newCamPos);
          controls.target.copy(center);
          camera.lookAt(center);
          controls.update();
        }
        params.selectedViewPreset = presetName;
        if (gui) {
          const presetController = gui.controllersRecursive().find((c) => c.property === 'selectedViewPreset');
          if (presetController && presetController.getValue() !== presetName) {
            presetController.setValue(presetName);
          } else if (presetController) {
            presetController.updateDisplay();
          }
        }
        isUpdatingViewPresetGUI = false;
      }

      function frameArea(objectToFrame, cam, ctrl, instant = false, fitOffset = 1.5) {
        if (!objectToFrame || !model) {
          logToScreen('frameArea: Objek model tidak valid atau belum dimuat.', 'warn');
          if (instant) {
            ctrl.target.set(0, 0, 0);
            cam.position.set(0, 0.5, 3);
            ctrl.update();
          }
          return;
        }
        const box = new THREE.Box3().setFromObject(objectToFrame);
        const sizeVec = box.getSize(new THREE.Vector3());
        const centerVec = new THREE.Vector3(0, 0, 0);
        if (sizeVec.lengthSq() === 0) {
          logToScreen('frameArea: Ukuran objek adalah nol.', 'warn');
          if (instant) {
            ctrl.target.copy(centerVec);
            cam.position.set(centerVec.x, centerVec.y + 0.5, centerVec.z + 3);
            ctrl.update();
          }
          return;
        }
        const maxSize = Math.max(sizeVec.x, sizeVec.y, sizeVec.z);
        const fitHeightDistance = maxSize / (2 * Math.atan((Math.PI * cam.fov) / 360));
        const fitWidthDistance = fitHeightDistance / cam.aspect;
        let distance = fitOffset * Math.max(fitHeightDistance, fitWidthDistance);
        distance = Math.max(distance, 0.1);
        const direction = new THREE.Vector3(0, 0.25, 1).normalize();
        const targetCamPos = centerVec.clone().add(direction.multiplyScalar(distance));
        cam.near = Math.max(0.01, distance / 100);
        cam.far = distance * 100;
        cam.updateProjectionMatrix();
        ctrl.maxDistance = distance * 10;
        ctrl.minDistance = Math.min(0.01, distance * 0.1);
        if (instant) {
          ctrl.target.copy(centerVec);
          cam.position.copy(targetCamPos);
          cam.lookAt(centerVec);
          ctrl.update();
        } else {
          ctrl.target.copy(centerVec);
          cam.position.copy(targetCamPos);
          cam.lookAt(centerVec);
          ctrl.update();
        }
      }

      function setupPresetButtons() {
        const buttons = document.querySelectorAll('.preset-button');
        buttons.forEach((button) => {
          button.addEventListener('click', () => {
            const view = button.getAttribute('data-view');
            goToViewPreset(view, false);
          });
        });
      }

      function setupGUI() {
        if (gui) gui.destroy();
        gui = new GUI();
        gui.title('Kontrol Model 3D');
        const modelFolder = gui.addFolder('Model');
        modelFolder.add(params, 'modelPath').name('Path Model (.glb)').onFinishChange((value) => {
          params.modelPath = value;
          loadMainModel();
        });
        modelFolder.add(params, 'modelScale', 0.01, 10, 0.01).name('Skala (Non-AR)').onChange(applyModelScale);
        modelFolder
          .add(params, 'arModelScale', 0.01, 5.0, 0.005)
          .name('Skala Model AR')
          .onChange((value) => {
            params.arModelScale = value;
            if (xrSession && modelPlaced && modelContainerGroup) {
              modelContainerGroup.scale.set(value, value, value);
              logToScreen(`Skala AR diupdate via GUI menjadi: ${value.toFixed(3)}`);
            } else if (xrSession && !modelPlaced && modelContainerGroup) {
              modelContainerGroup.scale.set(value, value, value);
              logToScreen(`Skala AR pre-placement diupdate via GUI menjadi: ${value.toFixed(3)}`);
            }
          });
        modelFolder.add(params, 'initialRotationX_deg', -360, 360, 1).name('Rotasi Awal X').onChange(applyInitialRotation);
        modelFolder.add(params, 'initialRotationY_deg', -360, 360, 1).name('Rotasi Awal Y').onChange(applyInitialRotation);
        modelFolder.add(params, 'initialRotationZ_deg', -360, 360, 1).name('Rotasi Awal Z').onChange(applyInitialRotation);
        modelFolder.add(params, 'animateModel').name('Animasi Putar (Non-AR)');
        modelFolder.add(params, 'rotationSpeed', 0, 1, 0.01).name('Kecepatan Putar');
        modelFolder.open();

        const backgroundFolder = gui.addFolder('Latar Belakang (Non-AR)');
        backgroundFolder.add(params, 'showSkybox').name('Tampilkan Skybox').onChange(updateBackgroundVisibility);
        backgroundFolder.add(params, 'skyboxGlbUrl').name('URL Skybox (.glb)').onFinishChange(loadSkyboxFromGLB);
        backgroundFolder
          .add(params, 'skyboxBrightness', 0, 5, 0.05)
          .name('Kecerahan Skybox')
          .onChange(() => {
            if (skyboxObject) loadSkyboxFromGLB();
          });
        backgroundFolder.addColor(params, 'backgroundColor').name('Warna Background').onChange((value) => {
          params.backgroundColor = value;
          updateBackgroundVisibility();
        });
        backgroundFolder.open();

        const cameraFolder = gui.addFolder('Kamera & Tampilan (Non-AR)');
        cameraFolder
          .add(params, 'cameraFOV', 10, 120, 1)
          .name('Field of View (FOV)')
          .onChange((value) => {
            camera.fov = value;
            camera.updateProjectionMatrix();
            if (!xrSession) goToViewPreset(params.selectedViewPreset, true);
          });
        cameraFolder
          .add(params, 'selectedViewPreset', ['Default', 'Front', 'Back', 'Top', 'Bottom', 'Left', 'Right'])
          .name('Preset Pandangan')
          .onChange((value) => {
            if (!isUpdatingViewPresetGUI) goToViewPreset(value, false);
          });
        cameraFolder.open();

        const lightingFolder = gui.addFolder('Pencahayaan');
        lightingFolder
          .add(params, 'ambientLightIntensity', 0, 5, 0.05)
          .name('Intensitas Ambient')
          .onChange((value) => {
            if (ambientLight) ambientLight.intensity = value;
          });
        lightingFolder
          .add(params, 'directionalLightIntensity', 0, 5, 0.05)
          .name('Intensitas Directional')
          .onChange((value) => {
            if (directionalLight) directionalLight.intensity = value;
          });
        lightingFolder
          .addColor(params, 'directionalLightColor')
          .name('Warna Directional')
          .onChange((value) => {
            if (directionalLight) directionalLight.color.setHex(value);
          });
        lightingFolder.open();

        const renderingFolder = gui.addFolder('Rendering');
        renderingFolder
          .add(params, 'toneMappingExposure', 0, 2, 0.01)
          .name('Exposure')
          .onChange((value) => {
            renderer.toneMappingExposure = value;
          });
        renderingFolder.open();

        const utilitiesFolder = gui.addFolder('Utilitas');
        utilitiesFolder.add({ takeScreenshot: takeScreenshot }, 'takeScreenshot').name('Ambil Screenshot (Non-AR)');
        utilitiesFolder.open();
      }

      function takeScreenshot() {
        try {
          if (xrSession) {
            logToScreen('Screenshot tidak didukung dalam mode AR.', 'warn');
            return;
          }
          composer.render();
          const dataURL = renderer.domElement.toDataURL('image/png');
          const a = document.createElement('a');
          a.href = dataURL;
          a.download = `model_view_${Date.now()}.png`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          logToScreen('Screenshot diambil!');
        } catch (e) {
          logToScreen(`Gagal mengambil screenshot: ${e.message}`, 'error');
        }
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
        if (model && !xrSession) goToViewPreset(params.selectedViewPreset, true);
      }

      function animate(timestamp, frame) {
        const deltaTime = clock.getDelta();
        if (!xrSession) {
          controls.update();
          if (modelContainerGroup && params.animateModel) {
            modelContainerGroup.rotation.y += params.rotationSpeed * deltaTime;
          }
          if (skyboxObject && skyboxObject.visible) {
            skyboxObject.position.copy(camera.position);
          }
          composer.render();
        } else {
          if (frame) {
            if (xrHitTestSource && !modelPlaced && reticleMesh) {
              const hitTestResults = frame.getHitTestResults(xrHitTestSource);
              if (hitTestResults.length > 0) {
                const hit = hitTestResults[0];
                const currentRefSpace = renderer.xr.getReferenceSpace();
                if (currentRefSpace) {
                  const pose = hit.getPose(currentRefSpace);
                  if (pose) {
                    reticleMesh.matrix.fromArray(pose.transform.matrix);
                    reticleMesh.visible = true;
                  } else {
                    reticleMesh.visible = false;
                  }
                } else {
                  reticleMesh.visible = false;
                }
              } else {
                reticleMesh.visible = false;
              }
            } else if (!modelPlaced && !xrHitTestSource && arInstructionsPanel.style.display === 'none' && reticleMesh) {
              reticleMesh.visible = true;
              const camWorldPos = new THREE.Vector3();
              const camWorldDir = new THREE.Vector3();
              camera.getWorldPosition(camWorldPos);
              camera.getWorldDirection(camWorldDir);
              reticleMesh.position.copy(camWorldPos).add(camWorldDir.multiplyScalar(0.7));
              reticleMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0));
              reticleMesh.lookAt(camWorldPos);
              reticleMesh.rotation.x = -Math.PI / 2;
              reticleMesh.updateMatrix();
            } else if (modelPlaced) {
              if (reticleMesh) reticleMesh.visible = false;
            }
          }
          renderer.render(scene, camera);
        }
      }

      // Modal handling not required now as loading overlay works exclusively

      init();
    </script>
  </body>
</html>
