<!DOCTYPE html>
<html lang="id">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>3D Model Viewer AR - OLEH FADHILLAH SUKMA ARINI</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet" />
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
          "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.js"
        }
      }
    </script>
    
    <style>
      /* Root Variables for Consistent Styling */
      :root {
        --primary-color: #FFD700; /* Gold Yellow for primary actions */
        --primary-hover: #E6B800; /* Darker Yellow for hover */
        --secondary-color: #34568B; /* Lapis Lazuli Blue for secondary elements */
        --error-color: #f44336; /* Red for errors or active AR stop */
        --surface-dark: rgba(30, 30, 30, 0.6); 
        --surface-darker: rgba(0, 0, 0, 0.9); /* For custom controls panel */
        --surface-medium: rgba(50, 50, 50, 0.5); 
        --surface-light: rgba(255, 255, 255, 0.1); 
        --text-primary: #ffffff;
        --text-secondary: rgba(255, 255, 255, 0.8);
        --text-placeholder: rgba(255, 255, 255, 0.5);
        --spacing-unit: 8px;
        --safe-area-inset-top: env(safe-area-inset-top, 16px); 
        --safe-area-inset-bottom: env(safe-area-inset-bottom, 20px);
        --safe-area-inset-left: env(safe-area-inset-left, 16px);
        --safe-area-inset-right: env(safe-area-inset-right, 16px);
        --border-radius-small: 6px;
        --border-radius-medium: 10px;  
        --border-radius-button: 4px;  
        --border-radius-large: 16px; 
        --border-radius-capsule: 50px; 
        --blur-intensity: 8px;
        --top-controls-height: calc(48px + var(--spacing-unit) * 1); /* Consistent height for top bar elements */
      }
      
      /* Global Reset and Body Styling */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: 'Plus Jakarta Sans', sans-serif;
        background: linear-gradient(135deg, #1a1a1a, #2c2c2c);  
        color: var(--text-primary);
        overflow: hidden;  
        height: 100vh;  
        position: relative;  
      }
      canvas {
        display: block;  
        width: 100%;
        height: 100%;
      }
      
      /* Loading Overlay */
      #loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: #111;  
        z-index: 3000;  
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: calc(var(--spacing-unit) * 2.5);  
      }
      #loading-overlay .loading-content {  
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: calc(var(--spacing-unit) * 1.5);  
      }
      #loading-overlay .logo-icon {  
        font-size: 3.5rem;  
        color: var(--primary-color);
        padding: var(--spacing-unit);
        background-color: rgba(255,255,255,0.05);  
        border-radius: 50%;  
        display: flex;
        align-items: center;
        justify-content: center;
        width: 70px;  
        height: 70px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        animation: pulse 2s infinite alternate;  
      }
      @keyframes pulse {
        0% { transform: scale(1); box-shadow: 0 4px 12px rgba(255, 215, 0, 0.2); }
        100% { transform: scale(1.05); box-shadow: 0 8px 20px rgba(255, 215, 0, 0.4); }
      }
      #loading-overlay .logo-text {  
        font-size: 1.4rem;  
        font-weight: 600;
        letter-spacing: 0.2px;
        padding: calc(var(--spacing-unit) * 1) calc(var(--spacing-unit) * 1.5);
        background: transparent;  
        border-radius: 12px;
        text-align: center;
        color: var(--text-primary);
        display: flex;
        flex-direction: column;  
        align-items: center;  
        gap: 5px;  
      }
      #loading-overlay .logo-text .oleh-text {
        font-size: 1.1rem;  
        font-weight: 500;
        color: var(--text-secondary);  
      }
      #loading-overlay .logo-text .name-text {
        font-size: 1.5rem;  
        font-weight: 700;
        color: var(--primary-color);  
      }
      #loading-overlay .spinner {
        border: 6px solid rgba(255, 255, 255, 0.2);  
        border-top: 6px solid var(--primary-color);
        border-radius: 50%;
        width: 50px;  
        height: 50px;
        animation: spin 1s linear infinite;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);  
      }
      #loading-overlay .version-loading {  
        font-size: 0.9rem;
        color: var(--text-secondary);
        font-weight: 500;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      
      body.loaded #loading-overlay {
        opacity: 0;
        transition: opacity 0.5s ease-out;
        pointer-events: none;  
      }
      
      /* AR Button - Bottom Center Rounded Rectangle */
      #ar-button-container {
        position: fixed;
        bottom: calc(var(--bottom-nav-height, 70px) + var(--safe-area-inset-bottom) + var(--spacing-unit) * 3); 
        left: 50%;
        transform: translateX(-50%);
        z-index: 1001; 
        display: flex;  
        align-items: center;  
      }
      #arButton {
        display: flex;
        align-items: center;
        gap: var(--spacing-unit);
        padding: 0 calc(var(--spacing-unit) * 2.5); 
        background: var(--primary-color);
        border: none;
        height: 50px; 
        border-radius: var(--border-radius-large); 
        color: #000; 
        font-weight: 700; 
        font-size: 1rem;  
        cursor: pointer;
        transition: all 0.2s ease, box-shadow 0.3s ease-in-out; 
        box-shadow: 0 0 12px 3px rgba(255, 215, 0, 0.4), 0 3px 8px rgba(0,0,0,0.25); 
        box-sizing: border-box;  
        animation: subtleGlow 2.5s infinite alternate ease-in-out;
      }

      @keyframes subtleGlow {
        0% {
          box-shadow: 0 0 12px 3px rgba(255, 215, 0, 0.4), 0 3px 8px rgba(0,0,0,0.25);
          transform: scale(1);
        }
        50% {
          box-shadow: 0 0 20px 8px rgba(255, 215, 0, 0.6), 0 5px 12px rgba(0,0,0,0.35);
          transform: scale(1.03);
        }
        100% {
          box-shadow: 0 0 12px 3px rgba(255, 215, 0, 0.4), 0 3px 8px rgba(0,0,0,0.25);
          transform: scale(1);
        }
      }

      #arButton:hover {
        background: var(--primary-hover);
        transform: scale(1.03); 
        box-shadow: 0 0 20px 8px rgba(255, 215, 0, 0.6), 0 5px 12px rgba(0,0,0,0.35); 
      }
      #arButton.ar-active {  
        background: var(--error-color);
        box-shadow: 0 4px 12px rgba(244, 67, 54, 0.3);
        color: #fff; 
        animation: none; 
      }
      #arButton.ar-active:hover {
         transform: scale(1.02); 
      }
      #arButton .material-icons-round {
        font-size: 1.3rem;  
      }
      
      /* AR Instructions Panel (Scanning) */
      #ar-instructions {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: var(--surface-dark);
        backdrop-filter: blur(var(--blur-intensity));  
        -webkit-backdrop-filter: blur(var(--blur-intensity));
        border-radius: var(--border-radius-large);  
        padding: calc(var(--spacing-unit) * 2.5);  
        width: calc(100% - var(--spacing-unit) * 5);  
        max-width: 360px;  
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        z-index: 1200;  
        display: none;  
        text-align: center;
      }
      #ar-instructions p {
        font-size: 0.95rem;  
        line-height: 1.6;  
        margin-bottom: calc(var(--spacing-unit) * 2.5);
      }
      #start-scan-button {
        width: 100%;
        padding: calc(var(--spacing-unit) * 1.75);  
        background: var(--primary-color);
        border: none;
        border-radius: var(--border-radius-medium);
        color: #000; 
        font-weight: 600;
        font-size: 0.95rem;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;  
        align-items: center;
        justify-content: center;
        gap: var(--spacing-unit);
        box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3);  
      }
      #start-scan-button:hover {
        background: var(--primary-hover);
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(255, 215, 0, 0.4);  
      }
      
      #start-scan-button .material-icons-round {
        font-size: 1.3rem;
      }

      /* AR Placement & Interaction Prompts */
      .ar-prompt { 
        position: fixed; 
        background-color: var(--surface-dark); 
        backdrop-filter: blur(var(--blur-intensity));
        -webkit-backdrop-filter: blur(var(--blur-intensity));
        color: var(--text-primary);
        padding: var(--spacing-unit) calc(var(--spacing-unit) * 2);
        font-size: 0.9rem;
        font-weight: 500;
        z-index: 1100;
        display: none;  
        text-align: center;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        animation: fadeInPrompt 0.3s ease-out;
        white-space: nowrap; 
        align-items: center; 
        gap: calc(var(--spacing-unit) * 0.75);
      }

      #ar-placement-prompt { 
        border: 2px solid var(--primary-color); 
        padding: calc(var(--spacing-unit)*1.25) calc(var(--spacing-unit) * 2.5);
        font-size: 0.95rem;
        border-radius: var(--border-radius-capsule);
      }
       #ar-placement-prompt .material-icons-round { 
        animation: tapAnimation 1.5s infinite ease-in-out;
      }

      @keyframes tapAnimation {
        0%, 100% { transform: scale(1) translateY(0); opacity: 1;}
        50% { transform: scale(1.15) translateY(-3px); opacity: 0.7;}
      }


      #ar-interaction-info { 
        bottom: calc(var(--bottom-nav-height, 70px) + var(--safe-area-inset-bottom) + var(--spacing-unit) * 3 + 50px + var(--spacing-unit) * 3 ); 
        left: 50%;
        transform: translateX(-50%);
        flex-direction: column; 
        gap: var(--spacing-unit);
        padding: calc(var(--spacing-unit) * 1.5);
        border-radius: var(--border-radius-large); 
      }
      #ar-interaction-info > span { 
        font-weight: 600;
        margin-bottom: calc(var(--spacing-unit) * 0.5);
      }
      .ar-interaction-gesture-hints {
        display: flex;
        gap: calc(var(--spacing-unit) * 2.5);
        align-items: center;
        justify-content: center;
      }
      .gesture-hint {
        display: flex;
        flex-direction: column; 
        align-items: center;
        gap: calc(var(--spacing-unit) * 0.5);
      }
      .gesture-hint .material-icons-round {
        font-size: 2rem; 
        color: var(--primary-color);
        padding: var(--spacing-unit);
        background-color: rgba(255,255,255,0.1);
        border-radius: 50%;
      }
      .gesture-hint .gesture-text {
        font-size: 0.8rem;
        color: var(--text-primary); 
        font-weight: 500;
      }
      
      @keyframes pinchZoomInOut {
        0%, 100% { transform: scale(1); }
        25% { transform: scale(0.8); } 
        50% { transform: scale(0.8); } 
        75% { transform: scale(1.2); } 
      }
      .gesture-hint .icon-pinch {
        animation: pinchZoomInOut 2.5s infinite ease-in-out;
      }
      
      @keyframes dragRotateArrows {
        0% { transform: translateX(-4px) rotate(-10deg); }
        25% { transform: translateX(4px) rotate(10deg); }
        50% { transform: translateX(-4px) rotate(-10deg); }
        75% { transform: translateX(4px) rotate(10deg); }
        100% { transform: translateX(-4px) rotate(-10deg); }
      }
      .gesture-hint .icon-drag {
         animation: dragRotateArrows 2.5s infinite ease-in-out;
      }


      @keyframes fadeInPrompt {
        from { opacity: 0; transform: translate(-50%, calc(-50% + 10px)); } 
        to { opacity: 1; transform: translate(-50%, -50%); }
      }
      .ar-prompt .material-icons-round {
        vertical-align: middle;
        margin-right: calc(var(--spacing-unit) * 0.5);
        font-size: 1.1rem;
      }
      
      /* Bottom Navigation Bar Wrapper */
      #bottom-nav-wrapper {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 1000;
        background: rgba(20, 20, 20, 0.3); 
        backdrop-filter: blur(var(--blur-intensity));
        -webkit-backdrop-filter: blur(var(--blur-intensity));
        padding: calc(var(--spacing-unit) * 1.5) 0 calc(var(--spacing-unit) + var(--safe-area-inset-bottom)) 0;  
        border-top-left-radius: var(--border-radius-medium);  
        border-top-right-radius: var(--border-radius-medium);  
        box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.25);
      }
      #bottom-nav-label {
        text-align: center;
        font-size: 0.75rem;
        color: var(--text-secondary);
        margin-bottom: calc(var(--spacing-unit) * 2.5); /* Increased margin */
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      .bottom-nav {
        display: flex;
        justify-content: flex-start; 
        align-items: center; 
        gap: var(--spacing-unit); 
        flex-wrap: nowrap; 
        overflow-x: auto; 
        padding-left: 0; 
        padding-right: 0; 
        padding-bottom: calc(var(--spacing-unit) * 2.5); /* Increased padding for scrollbar */
      }

      .bottom-nav::-webkit-scrollbar {
        height: 6px; 
      }
      .bottom-nav::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05); 
        border-radius: 10px;
      }
      .bottom-nav::-webkit-scrollbar-thumb {
        background-color: var(--primary-color); 
        border-radius: 10px;
      }
      .bottom-nav {
        scrollbar-width: thin;
        scrollbar-color: var(--primary-color) rgba(255, 255, 255, 0.05);
      }


      .view-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center; 
        gap: 1px; 
        width: 58px; 
        height: 48px; 
        padding: calc(var(--spacing-unit) * 0.4); 
        border-radius: var(--border-radius-medium); 
        border: none;
        background: var(--surface-light);
        color: var(--text-primary);
        font-family: inherit;
        font-weight: 500;
        font-size: 0.55rem; 
        cursor: pointer;
        transition: all 0.2s ease;
        text-align: center;
        line-height: 1.1; 
        flex-shrink: 0; 
      }
      .view-btn:hover {
        background: rgba(255, 255, 255, 0.2); 
        transform: translateY(-1px);
      }
      .view-btn .material-icons-round {
        font-size: 1.1rem; 
        margin-bottom: 1px; 
      }
      .view-btn.active {
        background: var(--primary-color);
        color: #000;  
        box-shadow: 0 4px 12px rgba(255, 215, 0, 0.5);  
      }
      .view-btn.active .material-icons-round {
        color: #000;  
      }
      
      /* On-Screen Log */
      #on-screen-log-container {
        position: fixed;
        bottom: calc(var(--bottom-nav-height, 70px) + var(--safe-area-inset-bottom) + var(--spacing-unit) * 3 + 50px + var(--spacing-unit) * 3 + 70px + var(--spacing-unit) * 2);
        left: calc(var(--spacing-unit) * 1.5);
        right: calc(var(--spacing-unit) * 1.5);  
        width: auto;  
        max-width: 400px;  
        margin-left: auto;  
        margin-right: auto;  
        max-height: 90px;  
        background: rgba(0, 0, 0, 0.75);  
        color: #ADD8E6;  
        font-family: monospace;
        font-size: 0.7rem;  
        padding: var(--spacing-unit);
        border-radius: var(--border-radius-small);
        overflow-y: auto;
        z-index: 999;  
        display: none; 
        border: 1px solid rgba(255,255,255,0.1);  
      }
      
      /* Top Left App Version Styling */
      #app-version-container { 
        position: fixed;
        top: calc(var(--safe-area-inset-top) + var(--spacing-unit)); 
        padding-top: var(--spacing-unit); 
        left: calc(var(--safe-area-inset-left) + var(--spacing-unit)); 
        z-index: 1001;  
        display: flex;
        align-items: center; 
        height: var(--top-controls-height);
      }
      #app-version {
        color: var(--text-secondary);
        font-size: 0.75rem;  
        font-weight: 500;
        background-color: rgba(0,0,0,0.4); 
        padding: calc(var(--spacing-unit) * 0.75) var(--spacing-unit); 
        border-radius: var(--border-radius-medium);
        line-height: 1.4;  
        display: flex;  
        flex-direction: column;  
        justify-content: center;  
        box-sizing: border-box;
        height: 100%; 
        gap: calc(var(--spacing-unit) * 0.5); 
      }
      #app-version-main {
        display: block;
      }
      #model-name-display {
        display: block;
        font-size: 0.7rem;  
        color: var(--text-placeholder);
      }

      /* Top Right Controls Container */
      #top-right-controls-container {
        position: fixed;
        top: calc(var(--safe-area-inset-top) + var(--spacing-unit)); 
        padding-top: var(--spacing-unit); 
        right: calc(var(--safe-area-inset-right) + var(--spacing-unit)); 
        z-index: 1001;
        display: flex;  
        align-items: center;  
        gap: var(--spacing-unit); 
        height: var(--top-controls-height); 
      }

      .top-right-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 48px; 
        height: 48px;
        background: var(--surface-medium); 
        backdrop-filter: blur(var(--blur-intensity));
        -webkit-backdrop-filter: blur(var(--blur-intensity));
        border: none;
        border-radius: 50%;  
        color: var(--text-primary);
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
      }
      .top-right-btn:hover {
        background: rgba(80, 80, 80, 0.6); 
        transform: translateY(-1px);
      }
      .top-right-btn .material-icons-round {
        font-size: 1.5rem; 
      }


      /* Custom Controls Panel */
      #custom-controls-panel {
        position: fixed;
        top: calc(var(--safe-area-inset-top) + var(--spacing-unit) + var(--top-controls-height) + var(--spacing-unit) * 2); 
        right: var(--safe-area-inset-right, 0px); 
        width: 300px;
        max-height: calc(100vh - (var(--safe-area-inset-top) + var(--spacing-unit) + var(--top-controls-height) + var(--spacing-unit) * 2) - var(--spacing-unit) - (var(--bottom-nav-height, 70px) + var(--safe-area-inset-bottom) + var(--spacing-unit) * 1.5)); 
        background-color: var(--surface-darker);
        backdrop-filter: blur(var(--blur-intensity));
        -webkit-backdrop-filter: blur(var(--blur-intensity));
        border-radius: var(--border-radius-medium) 0 0 var(--border-radius-medium);  
        box-shadow: -8px 0 24px rgba(0,0,0,0.3);  
        z-index: 1400;
        overflow-y: auto;
        padding: var(--spacing-unit);
        display: none;  
        color: var(--text-primary);
        transition: transform 0.3s ease-in-out;  
        transform: translateX(100%);  
      }
      #custom-controls-panel.visible {
        display: block;
        transform: translateX(0);  
      }
      #custom-controls-panel h3 {
        font-size: 1.1rem;
        font-weight: 600;
        padding: calc(var(--spacing-unit) * 1.5) var(--spacing-unit);
        margin: 0 calc(var(--spacing-unit) * -1);  
        background-color: rgba(255,255,255,0.05);
        border-top-left-radius: var(--border-radius-medium);
        border-top-right-radius: 0;  
        margin-bottom: var(--spacing-unit);
      }
      .control-section {
        margin-bottom: calc(var(--spacing-unit) * 2);
        padding: var(--spacing-unit);
        background-color: rgba(255,255,255,0.03);
        border-radius: var(--border-radius-small);
      }
      .control-section summary {
        font-weight: 600;
        font-size: 0.9rem;
        padding: var(--spacing-unit);
        cursor: pointer;
        list-style: none;  
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid rgba(255,255,255,0.1);
        margin-bottom: var(--spacing-unit);
      }
      .control-section summary::-webkit-details-marker { display: none; }  
      .control-section summary::after {
        content: 'expand_more';
        font-family: 'Material Icons Round';
        font-size: 1.2rem;
        transition: transform 0.2s ease;
      }
      .control-section[open] summary::after {
        transform: rotate(180deg);
      }
      .control-section .controls-content {
        padding-top: var(--spacing-unit);
        display: flex;
        flex-direction: column;
        gap: calc(var(--spacing-unit) * 1.5);
      }
      .control-item {
        display: flex;
        flex-direction: column;
        gap: calc(var(--spacing-unit) * 0.5);
      }
      .control-item label {
        font-size: 0.8rem;
        color: var(--text-secondary);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .control-item label .value-display {
        font-weight: 500;
        color: var(--text-primary);
      }
      .control-item input[type="text"],
      .control-item input[type="color"],
      .control-item select,
      .control-item button {
        width: 100%;
        padding: calc(var(--spacing-unit) * 1);
        background-color: var(--surface-medium);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: var(--border-radius-small);
        color: var(--text-primary);
        font-family: inherit;
        font-size: 0.85rem;
      }
      .control-item input[type="text"]::placeholder {
        color: var(--text-placeholder);
      }
      .control-item input[type="color"] {
        height: 36px;  
        padding: calc(var(--spacing-unit) * 0.5);
      }
      .control-item input[type="checkbox"] {
        margin-right: var(--spacing-unit);
        accent-color: var(--primary-color);
        transform: scale(1.1);
      }
       .control-item .checkbox-label-group {
        display: flex;
        align-items: center;
        font-size: 0.85rem;  
        color: var(--text-primary);
      }
      .control-item input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 8px;
        background: rgba(255,255,255,0.2);
        border-radius: 4px;
        cursor: pointer;
      }
      .control-item input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        background: var(--primary-color);
        border-radius: 50%;
        border: 2px solid var(--surface-darker);
      }
      .control-item input[type="range"]::-moz-range-thumb {
        width: 16px;
        height: 16px;
        background: var(--primary-color);
        border-radius: 50%;
        border: none;
      }
      .control-item button {
        background-color: var(--secondary-color);
        cursor: pointer;
        transition: background-color 0.2s ease;
      }
      .control-item button:hover {
        background-color: var(--primary-hover);
        color: #000;
      }

      /* Initial Instructions Overlay */
      #initial-instructions-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.92); 
        z-index: 2500; 
        display: flex;
        align-items: center;
        justify-content: center;
        padding: calc(var(--spacing-unit) * 2);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease-out;
      }
      #initial-instructions-overlay.visible {
        opacity: 1;
        pointer-events: auto;
      }
      .instructions-content {
        background-color: var(--surface-darker);
        padding: calc(var(--spacing-unit) * 2.5) calc(var(--spacing-unit) * 3); 
        border-radius: var(--border-radius-large);
        max-width: 550px; 
        width: 100%;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      }
      .instructions-content h2 {
        font-size: 1.6rem; 
        font-weight: 700;
        color: var(--primary-color);
        text-align: center;
        margin-bottom: calc(var(--spacing-unit) * 2.5);
      }
      .instructions-content h3 {
        font-size: 1.15rem; 
        font-weight: 600;
        margin-top: calc(var(--spacing-unit) * 2.5);
        margin-bottom: calc(var(--spacing-unit) * 1.5);
        border-bottom: 1px solid rgba(255,255,255,0.1);
        padding-bottom: calc(var(--spacing-unit) * 0.75);
        display: flex;
        align-items: center;
      }
      .instructions-content h3 .material-icons-round {
        margin-right: calc(var(--spacing-unit) * 1.25);
        color: var(--primary-color);
        animation: instructionIconPulse 2s infinite ease-in-out;
        font-size: 1.8rem; 
      }
      @keyframes instructionIconPulse {
        0%, 100% { transform: scale(1) rotate(0deg); }
        50% { transform: scale(1.1) rotate(5deg); }
      }
      .instructions-content p, .instructions-content ul {
        font-size: 0.95rem; 
        line-height: 1.65;
        margin-bottom: calc(var(--spacing-unit) * 1.5);
        color: var(--text-secondary);
      }
      .instructions-content ul {
        list-style-position: inside;
        padding-left: var(--spacing-unit);
      }
      .instructions-content li {
        margin-bottom: calc(var(--spacing-unit) * 0.75);
      }
      .instructions-content strong {
        color: var(--text-primary);
        font-weight: 600;
      }
      .instructions-content .highlight {
        color: var(--primary-color);
        font-weight: 600;
      }
      .instructions-content .button-example {
        background-color: var(--surface-light);
        padding: 2px 6px;
        border-radius: var(--border-radius-small);
        font-family: monospace;
        color: var(--primary-color);
        display: inline-flex; /* For icon alignment */
        align-items: center;
        gap: 4px;
      }
      .instructions-content p .material-icons-round, 
      .instructions-content li .material-icons-round {
        vertical-align: -5px; 
        font-size: 1.2em; 
        margin: 0 2px;
        color: var(--primary-color);
        animation: none; 
      }
      #close-initial-instructions {
        display: block;
        width: 100%;
        padding: calc(var(--spacing-unit) * 1.75); 
        background: var(--primary-color);
        border: none;
        border-radius: var(--border-radius-medium); 
        color: #000; 
        font-weight: 700; 
        font-size: 1.05rem; 
        cursor: pointer;
        transition: background-color 0.2s ease, transform 0.1s ease;
        margin-top: calc(var(--spacing-unit) * 3);
      }
      #close-initial-instructions:hover {
        background: var(--primary-hover);
        transform: scale(1.02);
      }
      
    </style>
  </head>
  <body>
    <div id="loading-overlay">
      <div class="loading-content">
        <span class="material-icons-round logo-icon">3d_rotation</span>
        <div class="logo-text">
          <span class="oleh-text">OLEH</span>
          <span class="name-text">FADHILLAH SUKMA ARINI</span>
        </div>
      </div>
      <div class="spinner"></div>
      <div class="version-loading">Version 2.8.7</div>  
    </div>

    <div id="initial-instructions-overlay">
      <div class="instructions-content">
        <h2>Selamat Datang di Penampil Model 3D!</h2>
        
        <div id="desktop-instructions-block" style="display: none;">
          <h3><span class="material-icons-round">mouse</span>Kontrol Desktop (Non-AR)</h3>
          <ul>
            <li><strong>Putar Model:</strong> Klik kiri & seret mouse.</li>
            <li><strong>Zoom Model:</strong> Scroll mouse wheel.</li>
            <li><strong>Geser/Pan Model:</strong> Klik kanan & seret mouse (atau Shift + Klik kiri & seret).</li>
          </ul>
        </div>

        <div id="mobile-instructions-block" style="display: none;">
          <h3><span class="material-icons-round">touch_app</span>Kontrol Mobile (Non-AR)</h3>
          <ul>
            <li><strong>Putar Model:</strong> Seret dengan satu jari.</li>
            <li><strong>Zoom Model:</strong> Cubit dengan dua jari (pinch in/out).</li>
            <li><strong>Geser/Pan Model:</strong> Seret dengan dua jari.</li>
          </ul>
        </div>

        <h3><span class="material-icons-round">menu_open</span>Menu Kontrol Model</h3>
        <p>Tekan tombol <span class="button-example"><span class="material-icons-round">menu</span></span> di pojok kanan atas untuk membuka panel kontrol. Di sana Anda dapat:</p>
        <ul>
            <li>Mengubah <strong>Path Model</strong> (.glb).</li>
            <li>Mengatur <strong>Skala Model</strong> (untuk mode Non-AR dan AR secara terpisah).</li>
            <li>Menyesuaikan <strong>Rotasi Awal</strong> model.</li>
            <li>Mengaktifkan/menonaktifkan <strong>Animasi Putar Otomatis</strong> (Non-AR).</li>
            <li>Mengubah <strong>Latar Belakang</strong>: tampilkan Skybox dari URL .glb atau pilih warna solid.</li>
            <li>Menyesuaikan <strong>FOV Kamera</strong> dan memilih <strong>Preset Pandangan</strong> cepat.</li>
            <li>Mengatur <strong>Intensitas & Warna Pencahayaan</strong> (Ambient & Directional).</li>
            <li>Mengontrol <strong>Exposure</strong> rendering.</li>
            <li>Mengambil <strong>Tangkapan Layar</strong> (Non-AR).</li>
        </ul>


        <h3><span class="material-icons-round">view_in_ar</span>Mode Augmented Reality (AR)</h3>
        <p>Tekan tombol besar <span class="button-example"><span class="material-icons-round">view_in_ar</span> AR Mode</span> di bagian tengah bawah layar untuk memproyeksikan model ke dunia nyata.</p>
        
        <h4>Langkah-langkah Menggunakan AR:</h4>
        <ol>
            <li><strong>Mulai Sesi AR:</strong> Setelah menekan tombol <span class="button-example"><span class="material-icons-round">view_in_ar</span> AR Mode</span>, berikan izin jika diminta. Tombol akan berubah menjadi <span class="button-example" style="background-color: var(--error-color); color: white;"><span class="material-icons-round">close</span> Hentikan AR</span>.</li>
            <li><strong>Pindai Permukaan:</strong> Anda akan melihat pesan <span class="button-example">"Arahkan kamera ke permukaan datar..."</span>. Gerakkan perangkat Anda perlahan mengarah ke lantai atau meja yang cukup terang dan bertekstur.</li>
            <li><strong>Tempatkan Model:</strong> Saat permukaan terdeteksi, sebuah <strong class="highlight">lingkaran kuning (reticle)</strong> akan muncul. Sebuah prompt <span class="button-example"><span class="material-icons-round">ads_click</span> Ketuk lingkaran...</span> akan muncul di dekat reticle. Ketuk layar pada posisi lingkaran tersebut untuk menempatkan model.</li>
            <li><strong>Interaksi dengan Model AR:</strong> Setelah model muncul, Anda dapat:
                <ul>
                    <li><span class="material-icons-round highlight">open_in_full</span> <strong>Ubah Ukuran (Skala):</strong> Gunakan gestur mencubit (pinch) dengan dua jari.</li>
                    <li><span class="material-icons-round highlight">drag_indicator</span> <strong>Putar Model:</strong> Seret model dengan satu jari.</li>
                </ul>
                 Petunjuk gestur ini juga akan muncul sesaat di layar.
            </li>
            <li><strong>Akhiri Sesi AR:</strong> Tekan tombol <span class="button-example" style="background-color: var(--error-color); color: white;"><span class="material-icons-round">close</span> Hentikan AR</span>.</li>
        </ol>

        <h3><span class="material-icons-round">construction</span>Tombol Utilitas Lainnya</h3>
        <p>Di pojok kanan atas, Anda juga akan menemukan (dari kiri ke kanan):</p>
        <ul>
            <li><span class="button-example"><span class="material-icons-round">help_outline</span></span> <strong>Tombol Bantuan:</strong> Untuk menampilkan kembali panduan ini.</li>
            <li><span class="button-example"><span class="material-icons-round">visibility_off</span></span> / <span class="button-example"><span class="material-icons-round">visibility</span></span> <strong>Toggle Log:</strong> Untuk menampilkan atau menyembunyikan log debug.</li>
            <li><span class="button-example"><span class="material-icons-round">menu</span></span> <strong>Menu Kontrol Model:</strong> Untuk membuka panel kustomisasi model.</li>
        </ul>
        <p>Di bagian bawah layar (Non-AR), terdapat tombol-tombol <span class="button-example"><span class="material-icons-round">flip_to_front</span> Depan</span>, <span class="button-example"><span class="material-icons-round">arrow_upward</span> Atas</span>, dll., untuk mengubah perspektif model dengan cepat.</p>


        <button id="close-initial-instructions">Saya Mengerti!</button>
      </div>
    </div>
    
    <div id="ar-button-container">
      <button id="arButton">
        <span class="material-icons-round">view_in_ar</span>
        <span id="arButtonText">Mulai AR</span>  
      </button>
    </div>
    
    <div id="top-right-controls-container">
        <button id="help-button" class="top-right-btn" title="Bantuan">
            <span class="material-icons-round">help_outline</span>
        </button>
        <button id="log-toggle-button" class="top-right-btn" title="Toggle Log">
            <span class="material-icons-round">visibility_off</span> 
        </button>
        <button id="guiToggleButton" class="top-right-btn" title="Kontrol Model">
            <span class="material-icons-round">menu</span>  
        </button>
    </div>


    <div id="ar-instructions"> <p>Arahkan kamera ke permukaan datar (lantai/meja) untuk memulai pemindaian.</p>
      <button id="start-scan-button">
        <span class="material-icons-round">radar</span>
        Mulai Pindai
      </button>
    </div>

    <div id="ar-placement-prompt" class="ar-prompt">
        <span class="material-icons-round">ads_click</span> Ketuk lingkaran untuk menempatkan model.
    </div>

    <div id="ar-interaction-info" class="ar-prompt">
        <span>Model Ditempatkan!</span>
        <div class="ar-interaction-gesture-hints">
            <div class="gesture-hint">
                <span class="material-icons-round icon-pinch">open_in_full</span>
                <span class="gesture-text">Cubit untuk Skala</span>
            </div>
            <div class="gesture-hint">
                <span class="material-icons-round icon-drag">drag_indicator</span>
                <span class="gesture-text">Seret untuk Putar</span>
            </div>
        </div>
    </div>
    
    <div id="reticle"></div> 
    
    <div id="app-version-container">
        <div id="app-version">
          <span id="app-version-main">APP VERSI 2.8.7</span>
          <span id="model-name-display">Model: N/A</span>
        </div>
    </div>
    <div id="on-screen-log-container"></div>
    
    <div id="custom-controls-panel">
      <h3>Kontrol Model 3D</h3>
      
      <details class="control-section" open>
        <summary>Model</summary>
        <div class="controls-content">
          <div class="control-item">
            <label for="ctrlModelPath">Path Model (.glb)</label>
            <input type="text" id="ctrlModelPath" placeholder="e.g., model.glb">
          </div>
          <div class="control-item">
            <label for="ctrlModelScale">Skala (Non-AR) <span id="ctrlModelScaleValue" class="value-display">1.00</span></label>
            <input type="range" id="ctrlModelScale" min="0.01" max="10" step="0.01">
          </div>
          <div class="control-item">
            <label for="ctrlArModelScale">Skala Model AR <span id="ctrlArModelScaleValue" class="value-display">0.500</span></label>
            <input type="range" id="ctrlArModelScale" min="0.01" max="5.0" step="0.005">
          </div>
          <div class="control-item">
            <label for="ctrlInitialRotationX">Rotasi Awal X <span id="ctrlInitialRotationXValue" class="value-display">0°</span></label>
            <input type="range" id="ctrlInitialRotationX" min="-360" max="360" step="1">
          </div>
          <div class="control-item">
            <label for="ctrlInitialRotationY">Rotasi Awal Y <span id="ctrlInitialRotationYValue" class="value-display">0°</span></label>
            <input type="range" id="ctrlInitialRotationY" min="-360" max="360" step="1">
          </div>
          <div class="control-item">
            <label for="ctrlInitialRotationZ">Rotasi Awal Z <span id="ctrlInitialRotationZValue" class="value-display">0°</span></label>
            <input type="range" id="ctrlInitialRotationZ" min="-360" max="360" step="1">
          </div>
          <div class="control-item checkbox-label-group">
            <input type="checkbox" id="ctrlAnimateModel">
            <label for="ctrlAnimateModel">Animasi Putar (Non-AR)</label>
          </div>
          <div class="control-item">
            <label for="ctrlRotationSpeed">Kecepatan Putar <span id="ctrlRotationSpeedValue" class="value-display">0.10</span></label>
            <input type="range" id="ctrlRotationSpeed" min="0" max="1" step="0.01">
          </div>
        </div>
      </details>

      <details class="control-section">
        <summary>Latar Belakang (Non-AR)</summary>
        <div class="controls-content">
          <div class="control-item checkbox-label-group">
            <input type="checkbox" id="ctrlShowSkybox">
            <label for="ctrlShowSkybox">Tampilkan Skybox</label>
          </div>
          <div class="control-item">
            <label for="ctrlSkyboxGlbUrl">URL Skybox (.glb)</label>
            <input type="text" id="ctrlSkyboxGlbUrl" placeholder="e.g., skybox.glb">
          </div>
          <div class="control-item">
            <label for="ctrlSkyboxBrightness">Kecerahan Skybox <span id="ctrlSkyboxBrightnessValue" class="value-display">1.00</span></label>
            <input type="range" id="ctrlSkyboxBrightness" min="0" max="5" step="0.05">
          </div>
          <div class="control-item">
            <label for="ctrlBackgroundColor">Warna Latar</label>
            <input type="color" id="ctrlBackgroundColor">
          </div>
        </div>
      </details>

      <details class="control-section">
        <summary>Kamera & Tampilan (Non-AR)</summary>
        <div class="controls-content">
          <div class="control-item">
            <label for="ctrlCameraFOV">Field of View (FOV) <span id="ctrlCameraFOVValue" class="value-display">50</span></label>
            <input type="range" id="ctrlCameraFOV" min="10" max="120" step="1">
          </div>
          <div class="control-item">
            <label for="ctrlSelectedViewPreset">Preset Pandangan</label>
            <select id="ctrlSelectedViewPreset">
              <option value="Default">Standar</option>
              <option value="Front">Depan</option>
              <option value="Back">Belakang</option>
              <option value="Top">Atas</option>
              <option value="Bottom">Bawah</option>
              <option value="Left">Kiri</option>
              <option value="Right">Kanan</option>
            </select>
          </div>
        </div>
      </details>

      <details class="control-section">
        <summary>Pencahayaan</summary>
        <div class="controls-content">
          <div class="control-item">
            <label for="ctrlAmbientLightIntensity">Intensitas Ambient <span id="ctrlAmbientLightIntensityValue" class="value-display">3.00</span></label>
            <input type="range" id="ctrlAmbientLightIntensity" min="0" max="5" step="0.05">
          </div>
          <div class="control-item">
            <label for="ctrlDirectionalLightIntensity">Intensitas Directional <span id="ctrlDirectionalLightIntensityValue" class="value-display">4.00</span></label>
            <input type="range" id="ctrlDirectionalLightIntensity" min="0" max="5" step="0.05">
          </div>
          <div class="control-item">
            <label for="ctrlDirectionalLightColor">Warna Directional</label>
            <input type="color" id="ctrlDirectionalLightColor">
          </div>
        </div>
      </details>

      <details class="control-section">
        <summary>Rendering</summary>
        <div class="controls-content">
          <div class="control-item">
            <label for="ctrlToneMappingExposure">Exposure <span id="ctrlToneMappingExposureValue" class="value-display">1.00</span></label>
            <input type="range" id="ctrlToneMappingExposure" min="0" max="2" step="0.01">
          </div>
        </div>
      </details>
      
      <details class="control-section">
        <summary>Utilitas</summary>
        <div class="controls-content">
          <div class="control-item">
            <button id="ctrlTakeScreenshot">Ambil Tangkapan Layar (Non-AR)</button>
          </div>
        </div>
      </details>

    </div>
    
    <div id="bottom-nav-wrapper">
        <div id="bottom-nav-label">Perspektif Model</div>
        <div class="bottom-nav">
            <button class="view-btn" data-view="Default">
                <span class="material-icons-round">restore</span> Standar
            </button>
            <button class="view-btn" data-view="Front">
                <span class="material-icons-round">flip_to_front</span> Depan
            </button>
            <button class="view-btn" data-view="Back">
                <span class="material-icons-round">flip_to_back</span> Belakang
            </button>
            <button class="view-btn" data-view="Top">
                <span class="material-icons-round">arrow_upward</span>
                Atas
            </button>
            <button class="view-btn" data-view="Bottom">
                <span class="material-icons-round">arrow_downward</span>
                Bawah
            </button>
            <button class="view-btn" data-view="Left">
                <span class="material-icons-round">arrow_back</span> Kiri
            </button>
            <button class="view-btn" data-view="Right">
                <span class="material-icons-round">arrow_forward</span> Kanan
            </button>
        </div>
    </div>
    
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { OutputPass } from "three/addons/postprocessing/OutputPass.js";

      // --- Global Variables ---
      let scene, camera, renderer, controls, composer;  
      let model, modelContainerGroup, ambientLight, directionalLight;
      let clock; // For animations and delta time
      const arInstructionsPanel = document.getElementById("ar-instructions");
      const startScanButton = document.getElementById("start-scan-button");
      const onScreenLogContainer = document.getElementById("on-screen-log-container");
      const appVersionMainText = document.getElementById("app-version-main");
      const modelNameDisplayText = document.getElementById("model-name-display");
      const logToggleButton = document.getElementById("log-toggle-button");
      const helpButton = document.getElementById("help-button"); 
      const guiToggleButton = document.getElementById("guiToggleButton"); 
      
      const initialInstructionsOverlay = document.getElementById("initial-instructions-overlay");
      const closeInitialInstructionsButton = document.getElementById("close-initial-instructions");
      const desktopInstructionsBlock = document.getElementById("desktop-instructions-block");
      const mobileInstructionsBlock = document.getElementById("mobile-instructions-block");
      const arPlacementPrompt = document.getElementById("ar-placement-prompt");
      const arInteractionInfo = document.getElementById("ar-interaction-info");
      let arInteractionInfoTimeout; // Timeout for hiding interaction info


      let skyboxObject = null; // To store the loaded skybox GLB
      const modelCenter = new THREE.Vector3(); // To store model's center
      const modelSize = new THREE.Vector3(); // To store model's size
      
      // AR specific variables
      let xrSession = null;
      let xrRefSpace = null;  // Reference space for AR
      let xrHitTestSource = null; // For detecting surfaces
      let reticleMesh;  // Visual indicator for AR placement
      let modelPlaced = false;  // Flag if model is placed in AR
      
      let isUpdatingViewPresetGUI = false;  // Flag to prevent recursion in GUI updates
      
      const APP_VERSION = "2.8.7"; // Updated version
      const INSTRUCTIONS_STORAGE_KEY = `modelViewerInstructionsSeen_v${APP_VERSION}`; 
      
      // AR Interaction State
      let arIsPinching = false;
      let arInitialPinchDistance = 0;
      let arIsDragging = false;
      let arLastDragX = 0;
      let arLastDragY = 0;
      const arDragSensitivity = 0.005;  // Adjust for faster/slower rotation in AR
      
      // --- Configuration Parameters ---
      const params = {
        modelPath: "Cupang.glb",  // Default model path
        skyboxGlbUrl: "inside_galaxy_skybox_hdri_360_panorama.glb",  // Default skybox path
        toneMappingExposure: 1.0,
        ambientLightIntensity: 3.0,
        directionalLightIntensity: 4.0,
        directionalLightColor: 0xffffff,
        initialRotationX_deg: 0.0, // Initial rotation in degrees
        initialRotationY_deg: 0.0,
        initialRotationZ_deg: 0.0,
        animateModel: false,  // Auto-rotate model in non-AR
        rotationSpeed: 0.1,  // Speed of auto-rotation
        selectedViewPreset: "Default", // Default camera view preset
        cameraFOV: 50, // Camera Field of View
        modelScale: 1.0,  // Scale for non-AR mode
        arModelScale: 0.5,  // Initial scale for AR mode
        skyboxBrightness: 1.0, // Brightness multiplier for skybox
        backgroundColor: "#1A2B3C",  // Default background color if no skybox
        showSkybox: true, // Whether to show skybox or solid color
      };
      
      const controlsPanel = {}; // To store references to custom control panel elements

      // --- Utility Functions ---

      /**
       * Logs messages to both the on-screen log and the browser console.
       * @param {string} message - The message to log.
       * @param {string} type - "info", "warn", or "error".
       */
      function logToScreen(message, type = "info") {
        if (onScreenLogContainer) {
          const logEntry = document.createElement("div");
          const timestamp = new Date().toLocaleTimeString();
          logEntry.textContent = `[${timestamp}] ${message}`;
          if (type === "error") logEntry.style.color = "#ff9999";  // Light red for errors
          else if (type === "warn") logEntry.style.color = "#ffd799";  // Light orange for warnings
          else logEntry.style.color = "#ADD8E6";  // Light blue for info
          onScreenLogContainer.appendChild(logEntry);
          onScreenLogContainer.scrollTop = onScreenLogContainer.scrollHeight;  // Auto-scroll
        }
        // Also log to browser console
        if (type === "error") console.error(message);
        else if (type === "warn") console.warn(message);
        else console.log(message);
      }

      /**
       * Hides the initial loading overlay smoothly.
       */
      function hideLoadingOverlay() {
        const loadingOverlay = document.getElementById("loading-overlay");
        if (loadingOverlay) {
          document.body.classList.add("loaded"); // Add class to trigger CSS transition
          setTimeout(() => {
            if (loadingOverlay.parentNode) {  // Check if still in DOM
                loadingOverlay.remove();
            }
          }, 600);  // Match CSS transition duration
        }
      }

      /**
       * Updates the displayed app version and current model name.
       */
      function updateAppVersionAndModelName() {
        if (appVersionMainText) appVersionMainText.textContent = `APP VERSI ${APP_VERSION}`;
        let modelName = "N/A";
        if (params.modelPath && typeof params.modelPath === 'string') {
            const pathParts = params.modelPath.split('/');
            const fileName = pathParts.pop();  // Get the last part (filename.ext)
            if (fileName) {
                modelName = fileName.split('.')[0];  // Remove extension
            }
        }
        if (modelNameDisplayText) modelNameDisplayText.textContent = `Model: ${modelName || "N/A"}`;
        // Also update version in loading screen if it's still somehow visible
        if (document.querySelector("#loading-overlay .version-loading")) {
            document.querySelector("#loading-overlay .version-loading").textContent = `Version ${APP_VERSION}`;
        }
      }

      /**
       * Shows the initial instructions overlay, adapting content for desktop/mobile.
       */
      function showInitialInstructions() {
        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        if (isTouchDevice) {
            if(mobileInstructionsBlock) mobileInstructionsBlock.style.display = 'block';
            if(desktopInstructionsBlock) desktopInstructionsBlock.style.display = 'none';
        } else {
            if(desktopInstructionsBlock) desktopInstructionsBlock.style.display = 'block';
            if(mobileInstructionsBlock) mobileInstructionsBlock.style.display = 'none';
        }
        if(initialInstructionsOverlay) initialInstructionsOverlay.classList.add('visible');
      }
      
      /**
       * Checks if instructions have been seen before (using localStorage) and shows them if not.
       */
      function checkAndShowInitialInstructions() {
        if (!localStorage.getItem(INSTRUCTIONS_STORAGE_KEY)) {
            showInitialInstructions();
        }
      }


      /**
       * Hides the initial instructions overlay and marks it as seen.
       */
      function hideInitialInstructions() {
        if(initialInstructionsOverlay) initialInstructionsOverlay.classList.remove('visible');
        localStorage.setItem(INSTRUCTIONS_STORAGE_KEY, 'true'); 
      }

      /**
       * Updates the 2D screen position of an HTML element to follow a 3D object.
       * @param {HTMLElement} element - The HTML element to position.
       * @param {THREE.Object3D} object3D - The 3D object to follow.
       * @param {number} offsetX - Horizontal offset in pixels.
       * @param {number} offsetY - Vertical offset in pixels.
       */
      function updateElementPositionRelativeTo3DObject(element, object3D, offsetX = 0, offsetY = -60) {
        if (!element || !object3D || !object3D.visible || !camera) {
            if(element) element.style.display = 'none'; // Hide if conditions not met
            return;
        }

        const vector = new THREE.Vector3();
        object3D.getWorldPosition(vector); // Get world position of the 3D object
        vector.project(camera); // Project 3D position to 2D screen space (-1 to +1)

        // If object is behind the camera, hide the element
        if (vector.z > 1) {
            element.style.display = 'none';
            return;
        }
        
        // Convert normalized device coordinates to screen pixels
        const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
        const y = (vector.y * -0.5 + 0.5) * renderer.domElement.clientHeight;

        element.style.left = `${x + offsetX}px`;
        element.style.top = `${y + offsetY}px`;
        element.style.transform = `translate(-50%, -50%)`;  // Center the element on the coords
        element.style.display = 'flex'; // Make it visible and use flex for centering icon/text
      }


      /**
       * Shows the AR interaction hints (pinch to scale, drag to rotate) for a few seconds.
       */
      function showARInteractionInfo() {
        if (arInteractionInfo) {
            arInteractionInfo.style.display = 'flex'; 
            clearTimeout(arInteractionInfoTimeout);  // Clear any existing timeout
            arInteractionInfoTimeout = setTimeout(() => {
                if(arInteractionInfo) arInteractionInfo.style.display = 'none';
            }, 7000);  // Hide after 7 seconds
        }
      }
      
      // --- Initialization ---
      function init() {
        clock = new THREE.Clock();  // For delta time in animation loop
        scene = new THREE.Scene();
        scene.background = new THREE.Color(params.backgroundColor);
        
        // Dynamically get bottom nav height for AR button positioning
        const bottomNavWrapper = document.getElementById('bottom-nav-wrapper');
        if (bottomNavWrapper) {
            const navHeight = bottomNavWrapper.offsetHeight;
            document.documentElement.style.setProperty('--bottom-nav-height', `${navHeight}px`);
        }


        // Setup camera
        camera = new THREE.PerspectiveCamera(
          params.cameraFOV,
          window.innerWidth / window.innerHeight,
          0.01,  // Near clipping plane (increased for AR stability if needed)
          10000  // Far clipping plane
        );
        camera.position.set(0, 1.6, 3);  // Default camera position
        
        // Setup renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // Alpha for AR transparency
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping; // For better HDR-like visuals
        renderer.toneMappingExposure = params.toneMappingExposure;
        renderer.outputColorSpace = THREE.SRGBColorSpace; // Correct color output
        renderer.xr.enabled = true;  // Enable WebXR capabilities
        document.body.appendChild(renderer.domElement);
        
        // Setup OrbitControls for non-AR navigation
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Smooth camera movement
        controls.dampingFactor = 0.05;
        controls.minDistance = 0.01;  // Allow zooming very close
        controls.maxDistance = 5000; // Allow zooming out far
        controls.target.set(0, 0, 0);  // Look at the origin initially
        
        // Setup lighting
        ambientLight = new THREE.AmbientLight(0xffffff, params.ambientLightIntensity);
        scene.add(ambientLight);
        
        directionalLight = new THREE.DirectionalLight(params.directionalLightColor, params.directionalLightIntensity);
        directionalLight.position.set(1, 1.5, 1).normalize(); // Light from top-right-front
        scene.add(directionalLight);
        
        // Group to hold the model, allowing easier manipulation of its origin and scale
        modelContainerGroup = new THREE.Group();
        scene.add(modelContainerGroup);
        
        // Setup AR Button
        const arButtonElement = document.getElementById("arButton");
        const arButtonTextElement = document.getElementById("arButtonText");
        const arButtonIconElement = arButtonElement.querySelector(".material-icons-round");  

        if (navigator.xr) {
          navigator.xr
            .isSessionSupported("immersive-ar")
            .then((supported) => {
              arButtonElement.style.display = "flex";  
              if (supported) {
                arButtonElement.addEventListener("click", onARButtonClick);
                arButtonElement.disabled = false;
                if (arButtonTextElement) arButtonTextElement.textContent = "Mulai AR"; 
                if (arButtonIconElement) arButtonIconElement.textContent = "view_in_ar"; 
                logToScreen("AR didukung oleh perangkat/browser ini.");
              } else {
                if (arButtonTextElement) arButtonTextElement.textContent = "AR Tidak Ada"; // More user-friendly
                if (arButtonIconElement) arButtonIconElement.textContent = "view_in_ar_off"; // Suggestive icon
                arButtonElement.disabled = true;
                logToScreen("AR tidak didukung oleh perangkat/browser ini.", "warn");
              }
            })
            .catch((err) => {
              logToScreen(`Error saat memeriksa dukungan AR: ${err.message}`, "error");
              if (arButtonTextElement) arButtonTextElement.textContent = "Error AR";
              if (arButtonIconElement) arButtonIconElement.textContent = "error_outline"; 
              arButtonElement.disabled = true;
              arButtonElement.style.display = "flex";
            });
        } else {
          arButtonElement.style.display = "flex";
          if (arButtonTextElement) arButtonTextElement.textContent = "XR Tidak Ada";
          if (arButtonIconElement) arButtonIconElement.textContent = "xr_off"; // Placeholder if no specific icon
          arButtonElement.disabled = true;
          logToScreen("WebXR API tidak tersedia di browser ini.", "warn");
        }
        
        // Setup AR Reticle (visual indicator for placement)
        reticleMesh = new THREE.Mesh(
          new THREE.RingGeometry(0.04, 0.055, 32).rotateX(-Math.PI / 2),  // Flat ring on the floor
          new THREE.MeshBasicMaterial({ color: 0xFFD700, opacity: 0.8, transparent: true, depthTest: false })  // Yellow, slightly transparent
        );
        reticleMesh.matrixAutoUpdate = false;  // Position will be updated manually from hit-test
        reticleMesh.visible = false;  // Initially hidden
        reticleMesh.renderOrder = 10;  // Render on top of most things
        scene.add(reticleMesh);
        
        // Load initial skybox and model
        if (params.skyboxGlbUrl && params.skyboxGlbUrl !== "SKYBOX_ANDA.glb" && !params.skyboxGlbUrl.includes("placehold.co")) {
          loadSkyboxFromGLB();
        } else {
          logToScreen("Path Skybox GLB tidak valid atau placeholder, skybox tidak akan dimuat secara otomatis.", "warn");
        }
        updateBackgroundVisibility();  // Apply initial background settings
        loadMainModel();  // Load the main 3D model
        
        // Setup Post-processing (EffectComposer for potential future effects)
        composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);
        const outputPass = new OutputPass();  // Ensures correct output encoding
        composer.addPass(outputPass);
        
        // Setup UI controls and event listeners
        setupCustomControls(); 
        setupPresetButtons(); // For bottom navigation view presets
        if(closeInitialInstructionsButton) closeInitialInstructionsButton.addEventListener('click', hideInitialInstructions);
        startScanButton.addEventListener("click", onStartScanButtonClick);
        
        if (helpButton) {
            helpButton.addEventListener('click', showInitialInstructions);
        }

        if (logToggleButton) {
            logToggleButton.addEventListener('click', () => {
                const logIcon = logToggleButton.querySelector('.material-icons-round');
                if (onScreenLogContainer.style.display === 'none' || onScreenLogContainer.style.display === '') {
                    onScreenLogContainer.style.display = 'block';
                    if(logIcon) logIcon.textContent = 'visibility'; // Icon shows log is visible
                    logToScreen("Log Tampil.");
                } else {
                    onScreenLogContainer.style.display = 'none';
                    if(logIcon) logIcon.textContent = 'visibility_off'; // Icon shows log is hidden
                    console.log("Log Sembunyi."); // Minimal console log when hiding
                }
            });
        }

        window.addEventListener("resize", onWindowResize, false);
        renderer.domElement.addEventListener("click", onSelectAR);  // For placing model in AR
        
        renderer.setAnimationLoop(animate); // Start the animation loop
        
        updateAppVersionAndModelName();  // Display initial version and model name
        checkAndShowInitialInstructions(); // Show instructions if first time
      }
      
      // --- WebXR (AR) Functions ---

      /**
       * Handles the AR button click to start or end an AR session.
       */
      function onARButtonClick() {
        const arButtonElement = document.getElementById("arButton");
        const arButtonTextElement = document.getElementById("arButtonText");
        const arButtonIconElement = arButtonElement.querySelector(".material-icons-round");
        
        if (!xrSession) { // If no active session, request one
          logToScreen("Mencoba memulai sesi AR...");
          navigator.xr
            .requestSession("immersive-ar", {
              requiredFeatures: ["hit-test", "dom-overlay"],  // Hit-testing for placement, dom-overlay for UI
              domOverlay: { root: document.body },  // Allow HTML UI elements in AR
            })
            .then(onSessionStarted)
            .catch((err) => {
              logToScreen(`Gagal memulai sesi AR: ${err.message}`, "error");
              logToScreen("Pastikan perangkat & browser mendukung AR, dan izin kamera diberikan.", "error");
              if (arButtonTextElement) arButtonTextElement.textContent = "Gagal AR";
              if (arButtonIconElement) arButtonIconElement.textContent = "error_outline";
              arButtonElement.classList.remove("ar-active");
            });
        } else { // If session active, end it
          logToScreen("Mengakhiri sesi AR...");
          xrSession.end();  
        }
      }
      
      /**
       * Called when an AR session successfully starts.
       * @param {XRSession} session - The newly started WebXR session.
       */
      function onSessionStarted(session) {
        logToScreen(`Sesi AR dimulai.`);
        xrSession = session;
        const arButtonElement = document.getElementById("arButton");
        const arButtonTextElement = document.getElementById("arButtonText");
        const arButtonIconElement = arButtonElement.querySelector(".material-icons-round");
        
        if (arButtonTextElement) arButtonTextElement.textContent = "Hentikan AR"; 
        if (arButtonIconElement) arButtonIconElement.textContent = "close";
        arButtonElement.classList.add("ar-active"); // Change button appearance
        
        // Hide non-AR UI elements
        document.getElementById("bottom-nav-wrapper").style.display = "none";
        document.getElementById("ar-button-container").style.display = "flex"; // Ensure AR button is visible


        // Close custom controls panel if open
        const customPanel = document.getElementById('custom-controls-panel');
        if (customPanel) customPanel.classList.remove('visible');  
        const guiToggleIcon = guiToggleButton.querySelector('.material-icons-round'); 
        if (guiToggleIcon) guiToggleIcon.textContent = 'menu';  // Reset icon


        if (skyboxObject) skyboxObject.visible = false;  // Hide skybox in AR
        scene.background = null;  // Transparent background for AR
        
        // Reset AR state
        xrRefSpace = null;
        xrHitTestSource = null;
        modelPlaced = false;
        if (arPlacementPrompt) arPlacementPrompt.style.display = 'none';
        if (arInteractionInfo) arInteractionInfo.style.display = 'none';  

        // Prepare model for AR: hide it, set AR scale
        if (modelContainerGroup) {
          modelContainerGroup.visible = false;  // Hide model until placed
          modelContainerGroup.userData.originalScale = modelContainerGroup.scale.clone();  // Store non-AR scale
          modelContainerGroup.scale.set(params.arModelScale, params.arModelScale, params.arModelScale);
          modelContainerGroup.userData.initialArScale = params.arModelScale;  // Store initial AR scale for pinch reference
          logToScreen(`Model disembunyikan, skala AR diatur ke: ${params.arModelScale}`);
        }
        reticleMesh.visible = false;  // Hide reticle until scanning starts
        arInstructionsPanel.style.display = "block";  // Show AR scanning instructions
        
        // Ensure on-screen log visibility matches toggle button state
        const logToggleIcon = logToggleButton.querySelector('.material-icons-round');
        if (logToggleIcon && logToggleIcon.textContent === 'visibility') { // If log was visible
            onScreenLogContainer.style.display = "block";  // Keep it visible in AR overlay
        } else {
            onScreenLogContainer.style.display = "none"; // Keep it hidden
        }
        
        // Ensure top UI elements are visible in AR overlay
        document.getElementById('app-version-container').style.display = "flex";  
        document.getElementById('top-right-controls-container').style.display = "flex";
        updateAppVersionAndModelName();  
        
        
        session.addEventListener("end", onSessionEnded);  // Handle session end
        
        // Set up reference space and renderer for AR
        renderer.xr.setReferenceSpaceType("local");  // 'local' is often best for AR placement
        renderer.xr
          .setSession(session)
          .then(() => { logToScreen("Sesi XR berhasil diset ke renderer."); })
          .catch((err) => {
            logToScreen(`Error saat set session ke renderer: ${err.message}`, "error");
            session.end().catch((e) => logToScreen(`Error mengakhiri sesi setelah setSession gagal: ${e.message}`, "error"));
          });
      }
      
      /**
       * Called when the "Start Scan" button in AR instructions is clicked.
       * Initiates hit-testing to find surfaces.
       */
      function onStartScanButtonClick() {
        logToScreen("Tombol 'Mulai Pindai Permukaan' ditekan.");
        arInstructionsPanel.style.display = "none";  // Hide instructions
        if (xrSession && !xrHitTestSource) { // If session active and no hit-test source yet
          xrSession.requestReferenceSpace("viewer") // 'viewer' space for hit-testing from camera's perspective
            .then((refSpaceViewer) => {
              logToScreen("Viewer reference space didapatkan untuk hit-test.");
              return xrSession.requestHitTestSource({ space: refSpaceViewer });
            })
            .then((source) => {
              xrHitTestSource = source;  // Store hit-test source
              reticleMesh.visible = true;  // Show reticle
              logToScreen("Hit test source berhasil didapatkan. Reticle aktif.");
            })
            .catch((err) => {
              logToScreen(`Error mendapatkan hit test source: ${err.message}`, "error");
              logToScreen("Tidak bisa memulai pemindaian permukaan. Coba lagi atau restart sesi AR.", "error");
              reticleMesh.visible = false;
              if (arPlacementPrompt) arPlacementPrompt.style.display = 'none';
            });
        } else if (xrHitTestSource) {
          logToScreen("Hit test source sudah ada. Reticle seharusnya sudah aktif.");
          reticleMesh.visible = true; // Ensure it's visible if already created
        } else if (!xrSession) {
          logToScreen("Sesi AR tidak aktif saat mencoba memulai pemindaian.", "warn");
        }
      }
      
      /**
       * Called when the AR session ends (either by user or error).
       * Cleans up AR state and restores non-AR view.
       */
      function onSessionEnded() {
        logToScreen("Sesi AR berakhir.");
        if (xrSession) {  // Ensure cleanup only if session existed
            xrSession.removeEventListener("end", onSessionEnded);  // Clean up listener
            xrSession = null;
        }
        
        const arButtonElement = document.getElementById("arButton");
        const arButtonTextElement = document.getElementById("arButtonText");
        const arButtonIconElement = arButtonElement.querySelector(".material-icons-round");
        
        if (arButtonTextElement) arButtonTextElement.textContent = "Mulai AR";
        if (arButtonIconElement) arButtonIconElement.textContent = "view_in_ar";
        arButtonElement.classList.remove("ar-active"); // Reset button appearance
        
        // Restore non-AR UI
        document.getElementById("bottom-nav-wrapper").style.display = "block"; 
        document.getElementById("ar-button-container").style.display = "flex"; 

        // Ensure custom controls panel is hidden and icon reset
        const customPanel = document.getElementById('custom-controls-panel');
        if (customPanel) customPanel.classList.remove('visible');  
        const guiToggleIcon = guiToggleButton.querySelector('.material-icons-round');
        if (guiToggleIcon) guiToggleIcon.textContent = 'menu';

        // Hide AR specific UI prompts
        if (arPlacementPrompt) arPlacementPrompt.style.display = 'none';
        if (arInteractionInfo) arInteractionInfo.style.display = 'none';
        clearTimeout(arInteractionInfoTimeout); // Clear any pending hide timeout


        arInstructionsPanel.style.display = "none"; // Hide AR instructions
        
        // Restore top UI elements if they were part of DOM overlay
        document.getElementById('app-version-container').style.display = "flex"; 
        document.getElementById('top-right-controls-container').style.display = "flex";
        updateAppVersionAndModelName();  
        
        
        reticleMesh.visible = false;  // Hide reticle
        if (xrHitTestSource) {
            xrHitTestSource.cancel();  // Cancel hit-test source
            xrHitTestSource = null;
        }
        
        // Remove AR touch listeners
        renderer.domElement.removeEventListener("touchstart", handleARtouchstart);
        renderer.domElement.removeEventListener("touchmove", handleARtouchmove);
        renderer.domElement.removeEventListener("touchend", handleARtouchend);
        arIsPinching = false; // Reset interaction states
        arIsDragging = false;
        logToScreen("Listener interaksi AR dihapus.");
        
        // Restore model visibility and scale
        if (modelContainerGroup) {
          modelContainerGroup.visible = true;
          if (modelContainerGroup.userData.originalScale) { // Restore original non-AR scale
            modelContainerGroup.scale.copy(modelContainerGroup.userData.originalScale);
            logToScreen(`Skala model dikembalikan ke non-AR: ${modelContainerGroup.scale.x.toFixed(2)}`);
          } else { // Fallback if originalScale wasn't stored
            modelContainerGroup.scale.set(params.modelScale, params.modelScale, params.modelScale);
          }
        }
        if (model) goToViewPreset('Default', true);  // Reset camera to default view
        updateBackgroundVisibility();  // Restore skybox/background color
      }
      
      /**
       * Handles tap events in AR to place the model.
       * @param {Event} event - The click/tap event.
       */
      function onSelectAR(event) {
        logToScreen(
          `onSelectAR. Sesi AR: ${!!xrSession}, Reticle: ${reticleMesh.visible}, Model Ditempatkan: ${modelPlaced}`
        );
        if (xrSession && reticleMesh.visible && !modelPlaced) { // If AR active, reticle visible, model not placed
          if (modelContainerGroup && model) {
            logToScreen("Mencoba menempatkan model. Matriks reticle:", reticleMesh.matrix.elements.map((n) => n.toFixed(2)).join(', '));
            // Place model at reticle's position and orientation
            modelContainerGroup.matrix.copy(reticleMesh.matrix);
            modelContainerGroup.matrix.decompose(modelContainerGroup.position, modelContainerGroup.quaternion, modelContainerGroup.scale);  // Apply matrix to model's transform
            modelContainerGroup.scale.set(params.arModelScale, params.arModelScale, params.arModelScale);  // Apply initial AR scale
            modelContainerGroup.userData.initialArScale = params.arModelScale;  // Store for pinch reference
            modelContainerGroup.visible = true;  // Make model visible
            modelPlaced = true;  // Set flag
            reticleMesh.visible = false;  // Hide reticle
            if (arPlacementPrompt) arPlacementPrompt.style.display = 'none'; // Hide placement prompt
            showARInteractionInfo();  // Show interaction hints

            logToScreen(`Model AR ditempatkan. Pos: ${modelContainerGroup.position.toArray().map((n) => n.toFixed(2))}, Skala: ${params.arModelScale}`);
            
            // Add touch listeners for AR interaction (pinch, drag)
            renderer.domElement.addEventListener("touchstart", handleARtouchstart, { passive: false });
            renderer.domElement.addEventListener("touchmove", handleARtouchmove, { passive: false });
            renderer.domElement.addEventListener("touchend", handleARtouchend, { passive: false });
            logToScreen("Listener interaksi AR (drag/pinch) ditambahkan.");
          } else {
            logToScreen("Model atau modelContainerGroup tidak siap untuk ditempatkan di AR.", "warn");
          }
        } else if (modelPlaced) {
             logToScreen("Model sudah ditempatkan. Tap dideteksi."); // Could be used for other interactions later
        } else {
          logToScreen("Kondisi untuk menempatkan model AR tidak terpenuhi (reticle tidak terlihat atau sesi AR tidak aktif).");
        }
      }
      
      // --- AR Touch Interaction Handlers ---

      /**
       * Calculates the distance between two touch points.
       * @param {TouchList} touches - The list of active touches.
       * @returns {number} The distance in pixels.
       */
      function getDistanceBetweenTouches(touches) {
        const touch1 = touches[0];
        const touch2 = touches[1];
        return Math.sqrt(Math.pow(touch2.clientX - touch1.clientX, 2) + Math.pow(touch2.clientY - touch1.clientY, 2));
      }
      
      /**
       * Handles touch start events for AR model interaction (drag/pinch).
       * @param {TouchEvent} event
       */
      function handleARtouchstart(event) {
        if (!xrSession || !modelPlaced || !modelContainerGroup) return;
        event.preventDefault();  // Prevent default browser actions like scrolling
        const touches = event.touches;
        if (touches.length === 1) {  // Single finger: start drag
          arIsDragging = true;
          arIsPinching = false;
          arLastDragX = touches[0].clientX;
          arLastDragY = touches[0].clientY;
          logToScreen("AR Drag Start");
        } else if (touches.length === 2) {  // Two fingers: start pinch
          arIsPinching = true;
          arIsDragging = false;
          arInitialPinchDistance = getDistanceBetweenTouches(touches);
          modelContainerGroup.userData.currentPinchStartScale = modelContainerGroup.scale.x;  // Store scale at pinch start
          logToScreen(`AR Pinch Start. Initial Distance: ${arInitialPinchDistance.toFixed(2)}, Start Scale: ${modelContainerGroup.userData.currentPinchStartScale.toFixed(3)}`);
        }
      }
      
      /**
       * Handles touch move events for AR model interaction.
       * @param {TouchEvent} event
       */
      function handleARtouchmove(event) {
        if (!xrSession || !modelPlaced || !modelContainerGroup) return;
        event.preventDefault();
        const touches = event.touches;
        if (arIsDragging && touches.length === 1) {  // Dragging with one finger
          const deltaX = touches[0].clientX - arLastDragX;
          const deltaY = touches[0].clientY - arLastDragY;
          modelContainerGroup.rotation.y += deltaX * arDragSensitivity;  // Rotate around Y axis (horizontal drag)
          modelContainerGroup.rotation.x += deltaY * arDragSensitivity;  // Rotate around X axis (vertical drag) - can be limited if desired
          arLastDragX = touches[0].clientX;
          arLastDragY = touches[0].clientY;
        } else if (arIsPinching && touches.length === 2) {  // Pinching with two fingers
          const currentPinchDistance = getDistanceBetweenTouches(touches);
          if (arInitialPinchDistance > 0 && modelContainerGroup.userData.currentPinchStartScale !== undefined) {
            const scaleFactor = currentPinchDistance / arInitialPinchDistance;
            let newScale = modelContainerGroup.userData.currentPinchStartScale * scaleFactor;
            // Clamp scale to reasonable min/max based on initial AR scale
            const minScale = modelContainerGroup.userData.initialArScale * 0.1;  // e.g., 10% of initial
            const maxScale = modelContainerGroup.userData.initialArScale * 10;   // e.g., 1000% of initial
            newScale = Math.max(minScale, Math.min(newScale, maxScale));
            modelContainerGroup.scale.set(newScale, newScale, newScale);
          }
        }
      }
      
      /**
       * Handles touch end events for AR model interaction.
       * @param {TouchEvent} event
       */
      function handleARtouchend(event) {
        if (!xrSession || !modelPlaced) return;
        if (arIsDragging && event.touches.length < 1) { // Drag ended
          arIsDragging = false;
          logToScreen("AR Drag End");
        }
        if (arIsPinching && event.touches.length < 2) {  // Pinch ended
          arIsPinching = false;
          if (modelContainerGroup) { // Update params.arModelScale with the final pinch scale
            params.arModelScale = modelContainerGroup.scale.x;  
            // Update GUI if panel is open
            if (controlsPanel.arModelScale) {
                controlsPanel.arModelScale.value = params.arModelScale;
                if (controlsPanel.arModelScaleValue) controlsPanel.arModelScaleValue.textContent = params.arModelScale.toFixed(3);
            }
          }
          logToScreen(`AR Pinch End. Final AR Scale: ${params.arModelScale.toFixed(3)}`);
        }
      }
      
      // --- Model and Scene Management ---

      /**
       * Loads the main 3D model from the path specified in `params.modelPath`.
       * Cleans up old model if present.
       */
      function loadMainModel() {
        logToScreen(`Mulai memuat model dari: ${params.modelPath}`);
        // Clean up previous model if it exists
        if (model) {
          modelContainerGroup.remove(model);
          model.traverse((node) => {  // Dispose of geometries and materials
            if (node.geometry) node.geometry.dispose();
            if (node.material) {
              if (Array.isArray(node.material)) node.material.forEach((mat) => mat.dispose());
              else node.material.dispose();
            }
          });
          model = null;
          logToScreen("Model lama dibersihkan.");
        }
        // Reset model properties
        modelCenter.set(0, 0, 0);
        modelSize.set(0, 0, 0);
        modelContainerGroup.position.set(0, 0, 0); // Reset container position
        modelContainerGroup.rotation.set(0, 0, 0); // Reset container rotation
        modelContainerGroup.quaternion.identity();  // Ensure quaternion is reset
        
        const mainModelLoader = new GLTFLoader();
        mainModelLoader.load(
          params.modelPath,
          function (gltf) {  // Success callback
            model = gltf.scene;
            if (!model) { // Handle cases where GLTF loads but scene is empty
              logToScreen(`GLTFLoader berhasil, tetapi gltf.scene kosong untuk: ${params.modelPath}`, "error");
              hideLoadingOverlay();  // Still hide loading
              updateAppVersionAndModelName();  // Update display
              return;
            }
            logToScreen("Model GLTF berhasil di-parse.");
            modelContainerGroup.add(model); // Add loaded model to the container group
            
            // Calculate bounding box and center the model within its container
            const box = new THREE.Box3().setFromObject(modelContainerGroup);  // Use container for accurate centering if model itself is offset
            box.getCenter(modelCenter);  // Get center of the bounding box
            box.getSize(modelSize); // Get size of the bounding box
            logToScreen(`Ukuran model awal: X:${modelSize.x.toFixed(2)}, Y:${modelSize.y.toFixed(2)}, Z:${modelSize.z.toFixed(2)}`);
            
            // Offset the container group so the model's calculated center is at the group's origin (0,0,0)
            modelContainerGroup.position.sub(modelCenter);  
            modelCenter.set(0,0,0); // Now the logical center for controls is the group's origin
            logToScreen("ModelContainerGroup dipusatkan ke origin.");
            
            // Apply initial transformations and material updates
            applyInitialRotation();  // Apply rotation from params
            applyModelScale();     // Apply scale from params
            updateMaterialProperties();  // Apply any custom material adjustments
            logToScreen("Model GLB utama berhasil dimuat dan disiapkan.");
            
            goToViewPreset(params.selectedViewPreset, true);  // Frame the model with the current preset
            hideLoadingOverlay();  // Hide loading screen
            updateAppVersionAndModelName();  // Update displayed model name
          },
          function (xhr) {  // Progress callback
            if (xhr.lengthComputable) {
              const percentComplete = (xhr.loaded / xhr.total) * 100;
              console.log(`Memuat Model: ${Math.round(percentComplete, 2)}%`);
            } else {
              console.log(`Memuat Model... (${(xhr.loaded / 1024 / 1024).toFixed(2)} MB)`); // Show MB loaded if total unknown
            }
          },
          function (error) {  // Error callback
            logToScreen(`Gagal memuat model GLB utama dari: ${params.modelPath}. Error: ${error.message || error}`, "error");
            hideLoadingOverlay();  // Hide loading screen on error too
            updateAppVersionAndModelName();  // Update display (e.g., to show "N/A")
          }
        );
      }
      
      /**
       * Applies the model scale based on whether in AR or non-AR mode.
       * Also re-frames the camera in non-AR mode after scaling.
       */
      function applyModelScale() {
        if (modelContainerGroup && model) {
          const scaleValue = xrSession ? params.arModelScale : params.modelScale;
          modelContainerGroup.scale.set(scaleValue, scaleValue, scaleValue);
          logToScreen(`Skala model diatur ke: ${scaleValue.toFixed(3)} (Sesi AR: ${!!xrSession})`);
          
          if (!xrSession) {  // If not in AR, re-calculate bounding box and re-frame
            const box = new THREE.Box3().setFromObject(modelContainerGroup);  // Get new bounding box after scaling
            box.getSize(modelSize);  // Update global modelSize
            goToViewPreset(params.selectedViewPreset, true);  // Re-frame with current preset
          } else {
            // In AR, initialArScale is used as a base for pinch-to-zoom calculations
            modelContainerGroup.userData.initialArScale = scaleValue;  
          }
        } else if (!model) {
          logToScreen("applyModelScale dipanggil tetapi model belum dimuat.", "warn");
        }
      }
      
      /**
       * Loads a skybox from a GLB file.
       * Ensures materials are set to BackSide and adjusts brightness.
       */
      function loadSkyboxFromGLB() {
        if (!params.skyboxGlbUrl || params.skyboxGlbUrl === "SKYBOX_ANDA.glb" || params.skyboxGlbUrl.includes("placehold.co")) {
          logToScreen("URL Skybox GLB tidak valid. Skybox tidak akan dimuat.", "warn");
          if (skyboxObject) {  // If an old skybox exists, remove it
            scene.remove(skyboxObject);
            skyboxObject.traverse((node) => {  // Dispose of its resources
                if (node.geometry) node.geometry.dispose();
                if (node.material) {
                   if (Array.isArray(node.material)) node.material.forEach((mat) => mat.dispose());
                   else node.material.dispose();
                }
            });
            skyboxObject = null;
          }
          updateBackgroundVisibility();  // Fallback to solid color
          return;
        }
        logToScreen(`Mulai memuat skybox dari: ${params.skyboxGlbUrl}`);
        const loader = new GLTFLoader();
        loader.load(
          params.skyboxGlbUrl,
          (gltf) => {  // Success callback
            if (skyboxObject) {  // Clean up previous skybox
              scene.remove(skyboxObject);
              skyboxObject.traverse((node) => { // Dispose resources
                if (node.geometry) node.geometry.dispose();
                if (node.material) {
                  if (Array.isArray(node.material)) node.material.forEach((mat) => mat.dispose());
                  else node.material.dispose();
                }
              });
            }
            skyboxObject = gltf.scene;
            skyboxObject.traverse((node) => {  // Process materials for skybox effect
              if (node.isMesh) {
                const materials = Array.isArray(node.material) ? node.material : [node.material];
                materials.forEach((material) => {
                  material.side = THREE.BackSide;  // Render inside of the skybox
                  // Adjust emissive/color based on brightness param, preserving original values
                  if (material.isMeshStandardMaterial || material.isMeshPhysicalMaterial) {
                    if (material.userData.initialEmissiveIntensityGLB === undefined) { // Store original if not already
                        material.userData.initialEmissiveIntensityGLB = material.emissiveIntensity !== undefined ? material.emissiveIntensity : 1;  // Default to 1 if undefined
                    }
                    material.emissiveIntensity = material.userData.initialEmissiveIntensityGLB * params.skyboxBrightness;
                    if (!material.emissiveMap) {  // If no emissive map, also scale emissive color
                        if (material.userData.initialEmissiveColorGLB === undefined) {
                            material.userData.initialEmissiveColorGLB = material.emissive ? material.emissive.clone() : new THREE.Color(0xffffff);  // Default to white
                        }
                        material.emissive.copy(material.userData.initialEmissiveColorGLB).multiplyScalar(params.skyboxBrightness);
                    }
                  } else if (material.isMeshBasicMaterial) {  // For basic materials, scale color
                    if (material.userData.initialColorGLB === undefined) {
                        material.userData.initialColorGLB = material.color ? material.color.clone() : new THREE.Color(0xffffff);
                    }
                    material.color.copy(material.userData.initialColorGLB).multiplyScalar(params.skyboxBrightness);
                  }
                  material.needsUpdate = true;
                });
              }
            });
            // Scale skybox to be very large, ensuring it encompasses the scene
            const skyboxScale = Math.max(camera.far * 0.5, 1000);  // Ensure it's large enough but not excessively so
            skyboxObject.scale.set(skyboxScale, skyboxScale, skyboxScale);
            skyboxObject.renderOrder = -10;  // Render behind everything else
            scene.add(skyboxObject);
            updateBackgroundVisibility();  // Apply visibility based on params
            logToScreen("Skybox GLB berhasil dimuat.");
          },
          undefined,  // Progress callback (optional)
          (error) => {  // Error callback
            logToScreen(`Gagal memuat Skybox GLB: ${params.skyboxGlbUrl}. Error: ${error.message || error}`, "error");
            if (skyboxObject) { scene.remove(skyboxObject); skyboxObject = null; } // Clean up on error
            updateBackgroundVisibility();  // Fallback to solid color
          }
        );
      }
      
      /**
       * Updates scene background based on whether skybox is shown/active or AR mode.
       */
      function updateBackgroundVisibility() {
        if (skyboxObject) {
          skyboxObject.visible = params.showSkybox && !xrSession;  // Skybox visible if toggled on AND not in AR
        }
        if (params.showSkybox && skyboxObject && skyboxObject.children.length > 0 && !xrSession) {
          scene.background = null;  // Let skybox be the background
        } else if (!xrSession) {  // Not in AR, and skybox not shown/loaded
          scene.background = new THREE.Color(params.backgroundColor); // Use solid color
        } else {  // In AR mode
          scene.background = null; // Transparent background for camera feed
        }
      }
      
      /**
       * Applies the initial rotation to the model container group.
       */
      function applyInitialRotation() {
        if (modelContainerGroup) {
          modelContainerGroup.rotation.set(
            THREE.MathUtils.degToRad(params.initialRotationX_deg),
            THREE.MathUtils.degToRad(params.initialRotationY_deg),
            THREE.MathUtils.degToRad(params.initialRotationZ_deg)
          );
        }
      }
      
      /**
       * Placeholder for updating material properties of the loaded model.
       */
      function updateMaterialProperties() {
        if (!model) return;
        model.traverse((node) => {
          if (node.isMesh && node.material) {
            // Example: Modify roughness, metalness, etc.
            // node.material.roughness = 0.5;
            // node.material.needsUpdate = true;
          }
        });
      }

      // --- Camera and View Management ---

      /**
       * Moves the camera to a predefined view preset (Front, Top, Default, etc.).
       * @param {string} presetName - The name of the preset.
       * @param {boolean} instant - If true, snaps instantly; otherwise, can be animated (currently snaps).
       */
      function goToViewPreset(presetName, instant = false) {
        if (isUpdatingViewPresetGUI) return;  // Prevent recursion if called from GUI change
        if (!modelContainerGroup || !camera || !controls || !model) {
          logToScreen("goToViewPreset: Komponen belum siap (model, kamera, atau kontrol).", "warn");
          return;
        }
        isUpdatingViewPresetGUI = true;  // Set flag
        
        // Target the model's logical center (which is the origin of modelContainerGroup)
        const center = new THREE.Vector3();  // modelContainerGroup is already centered at origin
        
        // Get current scaled size of the model for distance calculation
        const currentBox = new THREE.Box3();
        model.traverseVisible(obj => {  // Use model's local bounding box
            if(obj.isMesh) currentBox.expandByObject(obj);
        });
        currentBox.getSize(modelSize);  // Get local size
        modelSize.multiply(modelContainerGroup.scale); // Apply current container scale to get world size
        
        const maxDim = Math.max(modelSize.x, modelSize.y, modelSize.z, 0.1);  // Ensure non-zero max dimension
        const distanceFactor = 2.0;  // How far to place camera relative to model size
        let distance = maxDim * distanceFactor;
        distance = Math.max(distance, 0.2);  // Minimum distance to prevent camera being inside small models
        
        let newCamPos = new THREE.Vector3();
        camera.up.set(0, 1, 0);  // Default camera up vector
        
        // Determine camera position based on preset
        switch (presetName) {
          case "Front":  // View from +Z (Three.js default front)
            newCamPos.set(center.x, center.y, center.z + distance);
            break;
          case "Back":   // View from -Z
            newCamPos.set(center.x, center.y, center.z - distance);
            break;
          case "Left":   // View from +X
            newCamPos.set(center.x + distance, center.y, center.z);
            break;
          case "Right":  // View from -X
            newCamPos.set(center.x - distance, center.y, center.z);
            break;
          case "Top":
            newCamPos.set(center.x, center.y + distance, center.z + 0.0001); // Slight Z offset to avoid gimbal lock issues with lookAt
            camera.up.set(0, 0, -1);  // Look down, Z is "up" from camera's perspective
            break;
          case "Bottom":
            newCamPos.set(center.x, center.y - distance, center.z + 0.0001);
            camera.up.set(0, 0, 1);   // Look up, Z is "down"
            break;
          case "Default": // "Standar" in UI
          default:
            // Reset model transforms to initial params for Default view
            modelContainerGroup.position.set(0, 0, 0); // Already centered
            modelContainerGroup.rotation.set(
              THREE.MathUtils.degToRad(params.initialRotationX_deg),
              THREE.MathUtils.degToRad(params.initialRotationY_deg),
              THREE.MathUtils.degToRad(params.initialRotationZ_deg)
            );
            modelContainerGroup.scale.set(params.modelScale, params.modelScale, params.modelScale);

            // Standard camera position for default view
            camera.position.set(0, 1.6, 3); // A common viewing angle
            controls.target.set(0, 0, 0);  // Look at origin
            camera.up.set(0, 1, 0);  // Standard up
            controls.update();  // Apply changes
            
            // Update GUI selection
            params.selectedViewPreset = "Default";
            if (controlsPanel.selectedViewPreset && controlsPanel.selectedViewPreset.value !== "Default") {
                controlsPanel.selectedViewPreset.value = "Default";
            }
            isUpdatingViewPresetGUI = false; // Reset flag
            updateActiveButton(presetName); // Use "Default" for logic, UI shows "Standar"
            return; // Exit early for Default preset
        }
        
        // Apply new camera position and target (currently instant for all)
        if (instant) {
          camera.position.copy(newCamPos);
          controls.target.copy(center);
          camera.lookAt(center);  // Ensure camera looks at the center after up vector change
          controls.update();  // Crucial for OrbitControls to recognize changes
        } else {
          // For smooth transition (not implemented, but structure is here)
          // Could use a library like TWEEN.js or GSAP
          camera.position.copy(newCamPos);
          controls.target.copy(center);
          camera.lookAt(center);
          controls.update();
        }
        
        // Update GUI selection
        params.selectedViewPreset = presetName;  
        if (controlsPanel.selectedViewPreset && controlsPanel.selectedViewPreset.value !== presetName) {
            controlsPanel.selectedViewPreset.value = presetName;
        }
        isUpdatingViewPresetGUI = false; // Reset flag
        updateActiveButton(presetName);
      }
      
      /**
       * Frames the camera to fit a given 3D object. (Alternative to simple presets)
       * @param {THREE.Object3D} objectToFrame - The object to frame.
       * @param {THREE.PerspectiveCamera} cam - The camera.
       * @param {OrbitControls} ctrl - The orbit controls.
       * @param {boolean} instant - Snap instantly or animate (currently instant).
       * @param {number} fitOffset - Multiplier for distance calculation.
       */
      function frameArea(objectToFrame, cam, ctrl, instant = false, fitOffset = 1.5) {
        if (!objectToFrame || !model) {  // Ensure model is loaded
          logToScreen("frameArea: Objek model tidak valid atau belum dimuat.", "warn");
          if (instant) {  // Fallback position if no model
            ctrl.target.set(0, 0, 0);
            cam.position.set(0, 0.5, 3);  // Default-ish view
            ctrl.update();
          }
          return;
        }
        
        const box = new THREE.Box3();
        box.setFromObject(objectToFrame);  // Calculate bounding box of the object
        
        const sizeVec = box.getSize(new THREE.Vector3());
        const centerVec = box.getCenter(new THREE.Vector3());  // Center of the bounding box
        
        if (sizeVec.lengthSq() === 0) {  // Handle zero-size objects (e.g., empty group)
          logToScreen("frameArea: Ukuran objek adalah nol.", "warn");
          if (instant) {
            ctrl.target.copy(centerVec);  // Target the (potentially 0,0,0) center
            cam.position.set(centerVec.x, centerVec.y + 0.5, centerVec.z + 3); // Default offset
            ctrl.update();
          }
          return;
        }
        
        // Calculate distance to fit object in view based on FOV and aspect ratio
        const maxSize = Math.max(sizeVec.x, sizeVec.y, sizeVec.z);
        const fitHeightDistance = maxSize / (2 * Math.atan((Math.PI * cam.fov) / 360));
        const fitWidthDistance = fitHeightDistance / cam.aspect;
        let distance = fitOffset * Math.max(fitHeightDistance, fitWidthDistance);
        distance = Math.max(distance, 0.1);  // Minimum distance
        
        // Position camera along its current direction from the object's center
        const direction = cam.position.clone().sub(centerVec).normalize().multiplyScalar(distance);
        const targetCamPos = centerVec.clone().add(direction);
        
        // Fallback if camera is already at the center (avoid NaN direction)
        if (direction.lengthSq() < 0.001) { 
            targetCamPos.set(centerVec.x, centerVec.y + sizeVec.y * 0.5, centerVec.z + distance);  // Default to view from front-ish
        }
        
        // Adjust camera clipping planes based on new distance
        cam.near = Math.max(0.01, distance / 100);
        cam.far = distance * 100;
        cam.updateProjectionMatrix();
        
        // Adjust OrbitControls limits
        ctrl.maxDistance = distance * 10;
        ctrl.minDistance = Math.min(0.01, distance * 0.1);  // Allow closer zoom
        
        // Apply new camera position and target
        if (instant) {
          ctrl.target.copy(centerVec);
          cam.position.copy(targetCamPos);
          cam.lookAt(centerVec);  // Ensure camera is looking at the center
          ctrl.update();
        } else {  // Smooth transition (not implemented)
          ctrl.target.copy(centerVec);
          cam.position.copy(targetCamPos);
          cam.lookAt(centerVec);
          ctrl.update();
        }
      }

      /**
       * Updates the active state of the bottom navigation view preset buttons.
       * @param {string} activeView - The name of the currently active view.
       */
      function updateActiveButton(activeView) {
        const buttons = document.querySelectorAll(".view-btn");
        buttons.forEach(button => {
          if (button.getAttribute("data-view") === activeView) {
            button.classList.add("active");
          } else {
            button.classList.remove("active");
          }
        });
      }
      
      /**
       * Sets up event listeners for the view preset buttons in the bottom navigation.
       */
      function setupPresetButtons() {
        const buttons = document.querySelectorAll(".view-btn");
        buttons.forEach((button) => {
          button.addEventListener("click", () => {
            const view = button.getAttribute("data-view");
            goToViewPreset(view, false);  // Use non-instant transition (currently snaps)
          });
        });
        updateActiveButton(params.selectedViewPreset); // Set initial active button
      }
      
      // --- Custom Controls Panel (GUI) Setup ---
      function setupCustomControls() {
        const panel = document.getElementById('custom-controls-panel');
        const toggleButtonIcon = guiToggleButton.querySelector('.material-icons-round');

        // Toggle panel visibility
        guiToggleButton.addEventListener('click', () => { 
            panel.classList.toggle('visible');
            if (panel.classList.contains('visible')) {
                if(toggleButtonIcon) toggleButtonIcon.textContent = 'close';  // Change icon to close
                logToScreen("Panel Kontrol Model 3D dibuka.");
            } else {
                if(toggleButtonIcon) toggleButtonIcon.textContent = 'menu';   // Change icon to menu
                logToScreen("Panel Kontrol Model 3D ditutup.");
            }
        });

        // Helper to setup a range input control
        function setupRangeControl(paramKey, inputId, valueDisplayId, unit = '', toFixed = 2, callback) {
            controlsPanel[paramKey] = document.getElementById(inputId);
            controlsPanel[valueDisplayId] = document.getElementById(valueDisplayId); // Span to display value
            controlsPanel[paramKey].value = params[paramKey]; // Set initial value from params
            if(controlsPanel[valueDisplayId]) controlsPanel[valueDisplayId].textContent = parseFloat(params[paramKey]).toFixed(toFixed) + unit;

            controlsPanel[paramKey].addEventListener('input', (event) => {
                const value = parseFloat(event.target.value);
                params[paramKey] = value;
                if(controlsPanel[valueDisplayId]) controlsPanel[valueDisplayId].textContent = value.toFixed(toFixed) + unit;
                if (callback) callback(value); // Execute callback if provided
            });
        }
        
        // --- Model Controls ---
        controlsPanel.modelPath = document.getElementById('ctrlModelPath');
        controlsPanel.modelPath.value = params.modelPath;
        controlsPanel.modelPath.addEventListener('change', (event) => {  // Use 'change' for text input to update on blur/enter
            params.modelPath = event.target.value;
            loadMainModel();  // Reload model with new path
        });

        setupRangeControl('modelScale', 'ctrlModelScale', 'ctrlModelScaleValue', '', 2, applyModelScale);
        
        setupRangeControl('arModelScale', 'ctrlArModelScale', 'ctrlArModelScaleValue', '', 3, (value) => {
            params.arModelScale = value;
            // If in AR and model is placed, update its scale directly
            if (xrSession && modelPlaced && modelContainerGroup) {
                modelContainerGroup.scale.set(value, value, value);
                logToScreen(`Skala AR diupdate via GUI menjadi: ${value.toFixed(3)}`);
            } else if (xrSession && !modelPlaced && modelContainerGroup) { // If in AR but not placed, still update the container for when it IS placed
                modelContainerGroup.scale.set(value, value, value);
                logToScreen(`Skala AR pre-placement diupdate via GUI menjadi: ${value.toFixed(3)}`);
            }
        });

        setupRangeControl('initialRotationX_deg', 'ctrlInitialRotationX', 'ctrlInitialRotationXValue', '°', 0, applyInitialRotation);
        setupRangeControl('initialRotationY_deg', 'ctrlInitialRotationY', 'ctrlInitialRotationYValue', '°', 0, applyInitialRotation);
        setupRangeControl('initialRotationZ_deg', 'ctrlInitialRotationZ', 'ctrlInitialRotationZValue', '°', 0, applyInitialRotation);

        controlsPanel.animateModel = document.getElementById('ctrlAnimateModel');
        controlsPanel.animateModel.checked = params.animateModel;
        controlsPanel.animateModel.addEventListener('change', (event) => {
            params.animateModel = event.target.checked;
        });

        setupRangeControl('rotationSpeed', 'ctrlRotationSpeed', 'ctrlRotationSpeedValue', '', 2, (value) => {
            params.rotationSpeed = value;
        });

        // --- Background Controls ---
        controlsPanel.showSkybox = document.getElementById('ctrlShowSkybox');
        controlsPanel.showSkybox.checked = params.showSkybox;
        controlsPanel.showSkybox.addEventListener('change', (event) => {
            params.showSkybox = event.target.checked;
            updateBackgroundVisibility();
        });
        
        controlsPanel.skyboxGlbUrl = document.getElementById('ctrlSkyboxGlbUrl');
        controlsPanel.skyboxGlbUrl.value = params.skyboxGlbUrl;
        controlsPanel.skyboxGlbUrl.addEventListener('change', (event) => {
            params.skyboxGlbUrl = event.target.value;
            loadSkyboxFromGLB(); // Load new skybox
        });

        setupRangeControl('skyboxBrightness', 'ctrlSkyboxBrightness', 'ctrlSkyboxBrightnessValue', '', 2, () => {
            if (skyboxObject) loadSkyboxFromGLB();  // Reload skybox to apply new brightness
        });

        controlsPanel.backgroundColor = document.getElementById('ctrlBackgroundColor');
        controlsPanel.backgroundColor.value = params.backgroundColor;
        controlsPanel.backgroundColor.addEventListener('input', (event) => {  // 'input' for live color change
            params.backgroundColor = event.target.value;
            updateBackgroundVisibility();
        });
        
        // --- Camera & View Controls ---
        setupRangeControl('cameraFOV', 'ctrlCameraFOV', 'ctrlCameraFOVValue', '', 0, (value) => {
            camera.fov = value;
            camera.updateProjectionMatrix();
            if (!xrSession) goToViewPreset(params.selectedViewPreset, true); // Re-frame instantly after FOV change in non-AR
        });

        controlsPanel.selectedViewPreset = document.getElementById('ctrlSelectedViewPreset');
        controlsPanel.selectedViewPreset.value = params.selectedViewPreset;
        controlsPanel.selectedViewPreset.addEventListener('change', (event) => {
            if (!isUpdatingViewPresetGUI) goToViewPreset(event.target.value, false); // Go to selected preset
        });

        // --- Lighting Controls ---
        setupRangeControl('ambientLightIntensity', 'ctrlAmbientLightIntensity', 'ctrlAmbientLightIntensityValue', '', 2, (value) => {
            if (ambientLight) ambientLight.intensity = value;
        });

        setupRangeControl('directionalLightIntensity', 'ctrlDirectionalLightIntensity', 'ctrlDirectionalLightIntensityValue', '', 2, (value) => {
            if (directionalLight) directionalLight.intensity = value;
        });
        
        controlsPanel.directionalLightColor = document.getElementById('ctrlDirectionalLightColor');
        controlsPanel.directionalLightColor.value = '#' + new THREE.Color(params.directionalLightColor).getHexString(); // Convert hex number to string
        controlsPanel.directionalLightColor.addEventListener('input', (event) => {
            params.directionalLightColor = parseInt(event.target.value.replace("#",""), 16); // Convert hex string to number
            if (directionalLight) directionalLight.color.setHex(params.directionalLightColor);
        });

        // --- Rendering Controls ---
        setupRangeControl('toneMappingExposure', 'ctrlToneMappingExposure', 'ctrlToneMappingExposureValue', '', 2, (value) => {
            renderer.toneMappingExposure = value;
        });

        // --- Utilities ---
        controlsPanel.takeScreenshot = document.getElementById('ctrlTakeScreenshot');
        controlsPanel.takeScreenshot.addEventListener('click', takeScreenshot);
      }
      
      /**
       * Takes a screenshot of the current view (non-AR only).
       */
      function takeScreenshot() {
        try {
          if (xrSession) { // Screenshot not supported in AR overlay directly this way
            logToScreen("Tangkapan layar tidak didukung dalam mode AR.", "warn");
            return;
          }
          composer.render();  // Ensure scene is rendered with post-processing if any
          const dataURL = renderer.domElement.toDataURL("image/png");
          const a = document.createElement("a");
          a.href = dataURL;
          a.download = `model_view_${Date.now()}.png`; // Unique filename
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          logToScreen("Tangkapan layar diambil!");
        } catch (e) {
          logToScreen(`Gagal mengambil tangkapan layar: ${e.message}`, "error");
        }
      }
      
      // --- Event Handlers ---
      /**
       * Handles window resize events to update camera and renderer.
       */
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);  // Update composer size
        if (model && !xrSession) goToViewPreset(params.selectedViewPreset, true);  // Re-frame model on resize in non-AR

        // Recalculate bottom nav height on resize for accuracy if it changes (e.g. orientation change)
        const bottomNavWrapper = document.getElementById('bottom-nav-wrapper');
        if (bottomNavWrapper) {
            const navHeight = bottomNavWrapper.offsetHeight;
            document.documentElement.style.setProperty('--bottom-nav-height', `${navHeight}px`);
        }
      }
      
      // --- Animation Loop ---
      /**
       * The main animation loop, called by `renderer.setAnimationLoop`.
       * Handles rendering for both AR and non-AR modes.
       * @param {DOMHighResTimeStamp} timestamp - Current time.
       * @param {XRFrame} frame - WebXR frame object (only in AR).
       */
      function animate(timestamp, frame) {  // timestamp and frame are provided by WebXR when in AR session
        const deltaTime = clock.getDelta();  // Time since last frame
        
        if (!xrSession) {  // Non-AR mode
          controls.update();  // Update OrbitControls
          if (modelContainerGroup && params.animateModel) {  // Auto-rotate model if enabled
            modelContainerGroup.rotation.y += params.rotationSpeed * deltaTime;
          }
          if (skyboxObject && skyboxObject.visible) {  // Keep skybox centered on camera
            skyboxObject.position.copy(camera.position);
          }
          composer.render();  // Render scene via composer
        } else { // AR Mode
          if (frame) {  // If XRFrame is available
            const currentRefSpace = renderer.xr.getReferenceSpace();  // Get current reference space
            if (xrHitTestSource && !modelPlaced && reticleMesh && currentRefSpace) { // If hit-testing and model not placed
              const hitTestResults = frame.getHitTestResults(xrHitTestSource);  // Perform hit-test
              if (hitTestResults.length > 0) { // If a surface is found
                const hit = hitTestResults[0];
                const pose = hit.getPose(currentRefSpace);  // Get pose of the hit
                if (pose) {
                  reticleMesh.matrix.fromArray(pose.transform.matrix);  // Update reticle position/orientation
                  reticleMesh.visible = true;
                  // Update the 2D placement prompt to follow the 3D reticle
                  updateElementPositionRelativeTo3DObject(arPlacementPrompt, reticleMesh, 0, -70); 
                } else {  // No valid pose from hit
                    reticleMesh.visible = false;  
                    if(arPlacementPrompt) arPlacementPrompt.style.display = 'none';
                }
              } else {  // No hit results
                reticleMesh.visible = false;  
                if(arPlacementPrompt) arPlacementPrompt.style.display = 'none';
              }  
            } else if (modelPlaced) { // Model is placed, hide reticle and prompt
                if (reticleMesh) reticleMesh.visible = false;
                if (arPlacementPrompt) arPlacementPrompt.style.display = 'none';
            } else { // Model not placed, but also not hit-testing (e.g. before scan starts)
                 if(arPlacementPrompt) arPlacementPrompt.style.display = 'none';
            }
          }
          renderer.render(scene, camera);  // Render scene directly (composer not typically used in AR loop)
        }
      }
      
      // --- Start the Application ---
      init();
    </script>
  </body>
</ht
