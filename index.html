<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Model Viewer Sederhana dengan AR</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: #fff; font-family: 'Inter', sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; }
        canvas { display: block; width: 100%; height: 100%; }
        
        #ar-button-container {
            position: absolute;
            top: 10px;
            left: 10px; 
            z-index: 1000;
        }

        #arButton {
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            display: none; 
            width: 52px; 
            height: 52px; 
            font-size: 0.9em; 
            font-weight: bold;
            text-align: center;
            align-items: center;
            justify-content: center;
            padding: 0; 
            line-height: 1; 
        }
        #arButton:hover {
            background-color: #45a049;
        }
        #arButton.ar-active { 
            background-color: #f44336; 
        }
         #arButton.ar-active:hover {
            background-color: #d32f2f;
        }

        #loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5em;
            display: none;
            background-color: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 1001; 
        }
        :root {
            --lil-gui-background-color: #1a1a1a;
            --lil-gui-text-color: #ebebeb;
            --lil-gui-title-background-color: #101010;
            --lil-gui-title-text-color: #ebebeb;
            --lil-gui-widget-color: #333333;
            --lil-gui-hover-color: #444444;
            --lil-gui-focus-color: #555555;
            --lil-gui-number-color: #2cc9ff;
            --lil-gui-string-color: #a2e952;
        }
        #preset-buttons-container {
            position: absolute;
            bottom: 20px; 
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px; 
            z-index: 100;
            padding: 8px;
            background-color: rgba(0,0,0,0.6);
            border-radius: 12px;
            flex-wrap: wrap; 
            justify-content: center;
        }
        .preset-button {
            background-color: #333;
            color: #fff;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            transition: background-color 0.2s;
        }
        .preset-button:hover {
            background-color: #555;
        }
        .preset-button:active {
            background-color: #222;
        }

        .lil-gui.autoPlace {
            top: 10px;
            right: 10px;
            max-height: calc(100vh - 20px); 
            overflow-y: auto; 
            z-index: 1000; 
        }

        #reticle { 
            position: absolute;
            width: 35px; 
            height: 35px; 
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.75); 
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5); 
            box-sizing: border-box;
            display: none; 
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 99;
        }

        #ar-instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.85);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 1002; 
            display: none; 
            font-size: 1.1em;
        }
        #ar-instructions button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 15px;
            font-size: 1em;
        }
        #ar-instructions button:hover {
            background-color: #45a049;
        }

        #on-screen-log-container {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: calc(50% - 20px); 
            max-width: 400px;
            height: 100px; 
            background-color: rgba(0,0,0,0.6);
            color: #0f0; 
            font-family: monospace;
            font-size: 0.75em;
            padding: 8px;
            border-radius: 5px;
            overflow-y: scroll; 
            z-index: 1000;
            display: none; 
        }
        #app-version {
            position: absolute;
            bottom: 10px;
            left: 10px; 
            font-size: 0.7em;
            color: rgba(255,255,255,0.5);
            z-index: 1001;
             display: none; 
        }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.js"
        }
    }
    </script>
</head>
<body>
    <div id="loading-indicator">Memuat Model...</div>
    <div id="preset-buttons-container">
        <button class="preset-button" data-view="Default">Default</button>
        <button class="preset-button" data-view="Front">Depan</button>
        <button class="preset-button" data-view="Back">Belakang</button>
        <button class="preset-button" data-view="Top">Atas</button>
        <button class="preset-button" data-view="Bottom">Bawah</button>
        <button class="preset-button" data-view="Left">Kiri</button>
        <button class="preset-button" data-view="Right">Kanan</button>
    </div>
    <div id="ar-button-container">
        <button id="arButton">AR</button> 
    </div>
    <div id="ar-instructions">
        <p>Arahkan kamera ke permukaan datar (lantai/meja).</p>
        <button id="start-scan-button">Mulai Pindai Permukaan</button>
    </div>
    <div id="reticle"></div> 
    <div id="on-screen-log-container"></div>
    <div id="app-version">APP VERSI 0.0.5</div> <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import GUI from 'lil-gui';

        let scene, camera, renderer, controls, composer, gui;
        let model, modelContainerGroup, ambientLight, directionalLight;
        let clock;
        const loadingIndicator = document.getElementById('loading-indicator');
        const arInstructionsPanel = document.getElementById('ar-instructions');
        const startScanButton = document.getElementById('start-scan-button');
        const onScreenLogContainer = document.getElementById('on-screen-log-container');
        const appVersionDisplay = document.getElementById('app-version');
        
        let skyboxObject = null;
        const modelCenter = new THREE.Vector3(); 
        const modelSize = new THREE.Vector3(); 

        let xrSession = null;
        let xrViewerSpace = null; // Menyimpan viewer reference space
        let xrHitTestSource = null;
        let reticleMesh; 
        let modelPlaced = false; 
        let detectedPlanes = new Map(); // Untuk menyimpan visualisasi plane

        let isUpdatingViewPresetGUI = false;

        const APP_VERSION = "0.0.5"; // Versi aplikasi diupdate

        const params = {
            modelPath: 'Cupang.glb', 
            skyboxGlbUrl: 'inside_galaxy_skybox_hdri_360_panorama.glb', 
            toneMappingExposure: 1.0,
            ambientLightIntensity: 3.0, 
            directionalLightIntensity: 4.0, 
            directionalLightColor: 0xffffff,
            initialRotationX_deg: 0.0,
            initialRotationY_deg: 0.0,
            initialRotationZ_deg: 0.0,
            animateModel: false,
            rotationSpeed: 0.1,
            selectedViewPreset: 'Default',
            cameraFOV: 50, 
            modelScale: 1.0, 
            arModelScale: 0.25, // Skala AR default sedikit lebih besar
            arModelRotationY_deg: 0, // Untuk rotasi model di AR
            skyboxBrightness: 1.0,
            backgroundColor: '#4682B4', 
            showSkybox: true,
            showDetectedPlanes: true, // Opsi untuk menampilkan/menyembunyikan visualisasi plane
        };

        function logToScreen(message, type = 'info') {
            if (onScreenLogContainer) {
                const logEntry = document.createElement('div');
                const timestamp = new Date().toLocaleTimeString();
                logEntry.textContent = `[${timestamp}] ${message}`;
                if (type === 'error') {
                    logEntry.style.color = '#ff6666'; 
                } else if (type === 'warn') {
                    logEntry.style.color = '#ffcc66'; 
                } else {
                    logEntry.style.color = '#99ff99'; 
                }
                onScreenLogContainer.appendChild(logEntry);
                onScreenLogContainer.scrollTop = onScreenLogContainer.scrollHeight; 
            }
            if (type === 'error') console.error(message);
            else if (type === 'warn') console.warn(message);
            else console.log(message);
        }

        function init() {
            // ... (kode init lainnya tetap sama)
            if (loadingIndicator) loadingIndicator.style.display = 'block';
            clock = new THREE.Clock();
            scene = new THREE.Scene();
            scene.background = new THREE.Color(params.backgroundColor);
            
            camera = new THREE.PerspectiveCamera(params.cameraFOV, window.innerWidth / window.innerHeight, 0.01, 10000); 
            camera.position.set(0, 1.6, 3); 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = params.toneMappingExposure;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.xr.enabled = true; 
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 0.01; 
            controls.maxDistance = 5000; 
            controls.target.set(0, 0, 0); 

            ambientLight = new THREE.AmbientLight(0xffffff, params.ambientLightIntensity);
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(params.directionalLightColor, params.directionalLightIntensity);
            directionalLight.position.set(1, 1.5, 1).normalize(); 
            scene.add(directionalLight);
            
            modelContainerGroup = new THREE.Group();
            scene.add(modelContainerGroup);

            const arButtonElement = document.getElementById('arButton');
            if (navigator.xr) {
                navigator.xr.isSessionSupported('immersive-ar')
                    .then((supported) => {
                        arButtonElement.style.display = 'flex'; 
                        if (supported) {
                            arButtonElement.addEventListener('click', onARButtonClick);
                            arButtonElement.disabled = false;
                            arButtonElement.textContent = "AR"; 
                            logToScreen("AR didukung oleh perangkat/browser ini.");
                        } else {
                            arButtonElement.textContent = "No AR"; 
                            arButtonElement.disabled = true;       
                            logToScreen("AR tidak didukung oleh perangkat/browser ini.", "warn");
                        }
                    })
                    .catch((err) => { 
                         logToScreen(`Error saat memeriksa dukungan AR: ${err.message}`, "error");
                         arButtonElement.style.display = 'flex';
                         arButtonElement.textContent = "Err AR"; 
                         arButtonElement.disabled = true;
                    });
            } else {
                 arButtonElement.style.display = 'flex';
                 arButtonElement.textContent = "No XR";
                 arButtonElement.disabled = true;       
                 logToScreen("WebXR API tidak tersedia di browser ini.", "warn");
            }

            reticleMesh = new THREE.Mesh(
                new THREE.RingGeometry(0.04, 0.055, 32).rotateX(-Math.PI / 2), 
                new THREE.MeshBasicMaterial({ color: 0x00ff00, opacity:0.8, transparent:true, depthTest: false }) 
            );
            reticleMesh.matrixAutoUpdate = false;
            reticleMesh.visible = false;
            reticleMesh.renderOrder = 10; 
            scene.add(reticleMesh);

            if (params.skyboxGlbUrl && params.skyboxGlbUrl !== 'SKYBOX_ANDA.glb' && !params.skyboxGlbUrl.includes('placehold.co')) {
                loadSkyboxFromGLB();
            } else {
                logToScreen("Path Skybox GLB tidak valid atau menggunakan placeholder, skybox tidak akan dimuat secara otomatis.", "warn");
            }
            updateBackgroundVisibility();

            loadMainModel(); 

            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);
            const outputPass = new OutputPass();
            composer.addPass(outputPass);

            setupGUI();
            setupPresetButtons(); 
            startScanButton.addEventListener('click', onStartScanButtonClick);
            window.addEventListener('resize', onWindowResize, false);
            
            renderer.domElement.addEventListener('click', onSelectAR);
            renderer.setAnimationLoop(animate); 
        }
        
        function onARButtonClick() {
            const arButtonElement = document.getElementById('arButton');
            if (!xrSession) {
                logToScreen("Mencoba memulai sesi AR...");
                // Meminta fitur plane-detection
                navigator.xr.requestSession('immersive-ar', { 
                    requiredFeatures: ['hit-test', 'dom-overlay'], 
                    optionalFeatures: ['plane-detection'] // Jadikan plane-detection opsional
                }).then(onSessionStarted)
                  .catch(err => {
                      logToScreen(`Gagal memulai sesi AR: ${err.message}`, "error");
                      alert("Gagal memulai sesi AR. Pastikan perangkat & browser mendukung, dan izin kamera diberikan. Cek konsol untuk detail.");
                      arButtonElement.textContent = "AR Fail"; 
                  });
            } else {
                logToScreen("Mengakhiri sesi AR...");
                xrSession.end();
            }
        }

        function onSessionStarted(session) {
            logToScreen(`Sesi AR dimulai.`);
            xrSession = session;
            const arButtonElement = document.getElementById('arButton');
            arButtonElement.textContent = 'Stop'; 
            arButtonElement.classList.add('ar-active');

            document.getElementById('preset-buttons-container').style.display = 'none'; 
            if(gui) gui.hide(); 
            if(skyboxObject) skyboxObject.visible = false; 
            scene.background = null; 

            xrViewerSpace = null; // Reset viewer space
            xrHitTestSource = null; 
            modelPlaced = false; 
            if(modelContainerGroup) {
                modelContainerGroup.visible = false; 
                modelContainerGroup.userData.originalScale = modelContainerGroup.scale.clone();
                modelContainerGroup.scale.set(params.arModelScale, params.arModelScale, params.arModelScale);
                modelContainerGroup.rotation.y = THREE.MathUtils.degToRad(params.arModelRotationY_deg); // Terapkan rotasi awal AR
                logToScreen(`Model disembunyikan, skala AR diatur ke: ${params.arModelScale}, rotasi Y: ${params.arModelRotationY_deg} deg`);
            }
            reticleMesh.visible = false; 
            arInstructionsPanel.style.display = 'block'; 
            onScreenLogContainer.style.display = 'block'; 
            appVersionDisplay.style.display = 'block'; 
            appVersionDisplay.textContent = `APP VERSI ${APP_VERSION}`;

            session.addEventListener('end', onSessionEnded);
            
            renderer.xr.setReferenceSpaceType('local'); 
            renderer.xr.setSession(session)
                .then(() => {
                    logToScreen("Sesi XR berhasil diset ke renderer.");
                    return session.requestReferenceSpace('viewer'); // Dapatkan viewer space
                })
                .then((refSpace) => {
                    xrViewerSpace = refSpace; // Simpan viewer space
                    logToScreen("Viewer reference space didapatkan.");
                    // Hit test source akan diminta setelah tombol "Mulai Pindai" ditekan
                })
                .catch(err => {
                    logToScreen(`Error saat set session atau mendapatkan viewer space: ${err.message}`, "error");
                    session.end().catch(e => logToScreen(`Error mengakhiri sesi setelah setup gagal: ${e.message}`, "error"));
                });
        }

        function onStartScanButtonClick() {
            logToScreen("Tombol 'Mulai Pindai Permukaan' ditekan.");
            arInstructionsPanel.style.display = 'none'; 
            
            if (xrSession && !xrHitTestSource && xrViewerSpace) { // Pastikan viewerSpace ada
                xrSession.requestHitTestSource({ space: xrViewerSpace })
                    .then((source) => {
                        xrHitTestSource = source;
                        reticleMesh.visible = true; 
                        logToScreen("Hit test source berhasil didapatkan. Reticle aktif.");
                    })
                    .catch(err => {
                        logToScreen(`Error mendapatkan hit test source: ${err.message}`, "error");
                        alert("Tidak bisa memulai pemindaian permukaan. Coba lagi atau restart sesi AR.");
                        reticleMesh.visible = false;
                    });
            } else if (xrHitTestSource) {
                logToScreen("Hit test source sudah ada. Reticle seharusnya sudah aktif.");
                reticleMesh.visible = true;
            } else if (!xrSession) {
                logToScreen("Sesi AR tidak aktif saat mencoba memulai pemindaian.", "warn");
            } else if (!xrViewerSpace) {
                logToScreen("Viewer reference space belum siap untuk hit-testing.", "warn");
            }
        }

        function onSessionEnded() {
            logToScreen("Sesi AR berakhir.");
            xrSession = null;
            xrViewerSpace = null; // Reset viewer space
            const arButtonElement = document.getElementById('arButton');
            arButtonElement.textContent = 'AR';
            arButtonElement.classList.remove('ar-active');

            document.getElementById('preset-buttons-container').style.display = 'flex'; 
            if(gui) gui.show(); 
            arInstructionsPanel.style.display = 'none'; 
            onScreenLogContainer.style.display = 'none'; 
            appVersionDisplay.style.display = 'none'; 

            reticleMesh.visible = false;
            // Hapus visualisasi plane
            detectedPlanes.forEach(planeMesh => scene.remove(planeMesh));
            detectedPlanes.clear();


            if(modelContainerGroup) {
                modelContainerGroup.visible = true; 
                if (modelContainerGroup.userData.originalScale) {
                    modelContainerGroup.scale.copy(modelContainerGroup.userData.originalScale);
                    logToScreen(`Skala model dikembalikan ke non-AR: ${modelContainerGroup.scale.x.toFixed(2)}`);
                } else { 
                    modelContainerGroup.scale.set(params.modelScale, params.modelScale, params.modelScale);
                }
                 modelContainerGroup.rotation.y = THREE.MathUtils.degToRad(params.initialRotationY_deg); // Kembalikan rotasi non-AR
            }
            if(model) goToViewPreset(params.selectedViewPreset, true); 
            updateBackgroundVisibility(); 
        }
        
        function onSelectAR(event) {
            logToScreen(`onSelectAR. Sesi AR: ${!!xrSession}, Reticle: ${reticleMesh.visible}, Model Ditempatkan: ${modelPlaced}`);
            if (xrSession && reticleMesh.visible && !modelPlaced) {
                if (modelContainerGroup && model) { 
                    logToScreen("Mencoba menempatkan model. Matriks reticle:", reticleMesh.matrix.elements.map(n => n.toFixed(2)).join(', '));
                    
                    modelContainerGroup.matrix.copy(reticleMesh.matrix);
                    modelContainerGroup.matrix.decompose(modelContainerGroup.position, modelContainerGroup.quaternion, modelContainerGroup.scale); 
                    
                    modelContainerGroup.scale.set(params.arModelScale, params.arModelScale, params.arModelScale); 
                    // Terapkan rotasi Y dari GUI
                    modelContainerGroup.rotation.y = THREE.MathUtils.degToRad(params.arModelRotationY_deg);

                    modelContainerGroup.visible = true;
                    modelPlaced = true;
                    reticleMesh.visible = false; 

                    logToScreen(`Model AR ditempatkan. Pos: ${modelContainerGroup.position.toArray().map(n=>n.toFixed(2))}, Skala: ${params.arModelScale}, RotY: ${params.arModelRotationY_deg} deg`);

                    if (xrHitTestSource) {
                        xrHitTestSource = null; 
                        logToScreen("Hit test source dihentikan setelah penempatan.");
                    }
                } else {
                    logToScreen("Model atau modelContainerGroup tidak siap untuk ditempatkan di AR.", "warn");
                }
            } else {
                 logToScreen("Kondisi untuk menempatkan model AR tidak terpenuhi.");
            }
        }

        function loadMainModel() {
            // ... (fungsi loadMainModel tetap sama)
            if (loadingIndicator) {
                loadingIndicator.style.display = 'block';
                loadingIndicator.textContent = 'Memuat Model...';
                loadingIndicator.style.color = '#fff';
            }
            logToScreen(`Mulai memuat model dari: ${params.modelPath}`);

            if (model) {
                modelContainerGroup.remove(model);
                model.traverse(node => {
                    if (node.geometry) node.geometry.dispose();
                    if (node.material) {
                        if (Array.isArray(node.material)) node.material.forEach(mat => mat.dispose());
                        else node.material.dispose();
                    }
                });
                model = null;
                logToScreen("Model lama dibersihkan.");
            }
            modelCenter.set(0,0,0);
            modelSize.set(0,0,0);
            modelContainerGroup.position.set(0,0,0);
            modelContainerGroup.rotation.set(0,0,0);

            const mainModelLoader = new GLTFLoader();
            mainModelLoader.load(params.modelPath, function (gltf) {
                model = gltf.scene;
                if (!model) {
                    logToScreen(`GLTFLoader berhasil, tetapi gltf.scene kosong atau tidak valid untuk path: ${params.modelPath}`, "error");
                    if (loadingIndicator) {
                        loadingIndicator.innerHTML = `Gagal memproses model.<br>File "${params.modelPath}" mungkin tidak valid.`;
                        loadingIndicator.style.color = 'red';
                    }
                    return;
                }
                logToScreen("Model GLTF berhasil di-parse.");

                modelContainerGroup.add(model);
                
                const box = new THREE.Box3().setFromObject(modelContainerGroup);
                box.getCenter(modelCenter);
                box.getSize(modelSize);
                logToScreen(`Ukuran model awal: X:${modelSize.x.toFixed(2)}, Y:${modelSize.y.toFixed(2)}, Z:${modelSize.z.toFixed(2)}`);
                
                modelContainerGroup.position.sub(modelCenter); 
                modelCenter.set(0,0,0); 
                logToScreen("ModelContainerGroup dipusatkan.");

                applyInitialRotation();
                applyModelScale(); 
                updateMaterialProperties(); 
                
                logToScreen("Model GLB utama berhasil dimuat dan disiapkan.");
                if (loadingIndicator) loadingIndicator.style.display = 'none';
                
            }, 
            function (xhr) { 
                if (xhr.lengthComputable) {
                    const percentComplete = xhr.loaded / xhr.total * 100;
                    if (loadingIndicator) loadingIndicator.textContent = `Memuat Model: ${Math.round(percentComplete, 2)}%`;
                } else {
                    if (loadingIndicator) loadingIndicator.textContent = `Memuat Model... (${(xhr.loaded / 1024 / 1024).toFixed(2)} MB)`;
                }
            },
            function (error) { 
                logToScreen(`Gagal memuat model GLB utama dari path: ${params.modelPath}. Error: ${error.message || error}`, "error");
                if (loadingIndicator) {
                    loadingIndicator.innerHTML = `Gagal memuat model.<br>Pastikan file "${params.modelPath}" ada di direktori yang sama atau path URL benar. Cek konsol untuk detail error.`;
                    loadingIndicator.style.color = 'red';
                }
            });
        }

        function applyModelScale() {
            if (modelContainerGroup && model) { 
                const scaleValue = xrSession ? params.arModelScale : params.modelScale;
                modelContainerGroup.scale.set(scaleValue, scaleValue, scaleValue);
                logToScreen(`Skala model diatur ke: ${scaleValue.toFixed(3)} (Sesi AR: ${!!xrSession})`);
                
                if (!xrSession) { 
                    const box = new THREE.Box3().setFromObject(modelContainerGroup);
                    box.getSize(modelSize); 
                    goToViewPreset(params.selectedViewPreset, true); 
                }
            } else if (!model) {
                logToScreen("applyModelScale dipanggil tetapi model belum dimuat.", "warn");
            }
        }
        
        function loadSkyboxFromGLB() {
            // ... (fungsi loadSkyboxFromGLB tetap sama)
             if (!params.skyboxGlbUrl || params.skyboxGlbUrl === 'SKYBOX_ANDA.glb' || params.skyboxGlbUrl.includes('placehold.co')) {
                logToScreen("URL Skybox GLB tidak valid atau placeholder. Skybox tidak akan dimuat.", "warn");
                if (skyboxObject) {
                    scene.remove(skyboxObject);
                    skyboxObject.traverse(node => {
                        if (node.geometry) node.geometry.dispose();
                        if (node.material) {
                            if (Array.isArray(node.material)) node.material.forEach(mat => mat.dispose());
                            else node.material.dispose();
                        }
                    });
                    skyboxObject = null;
                }
                updateBackgroundVisibility();
                return;
            }
            logToScreen(`Mulai memuat skybox dari: ${params.skyboxGlbUrl}`);
            const loader = new GLTFLoader();
            loader.load(params.skyboxGlbUrl,
                (gltf) => {
                    if (skyboxObject) { 
                        scene.remove(skyboxObject);
                         skyboxObject.traverse(node => {
                            if (node.geometry) node.geometry.dispose();
                            if (node.material) {
                                if (Array.isArray(node.material)) node.material.forEach(mat => mat.dispose());
                                else node.material.dispose();
                            }
                        });
                    }
                    skyboxObject = gltf.scene;
                    skyboxObject.traverse(node => {
                        if (node.isMesh) {
                            const materials = Array.isArray(node.material) ? node.material : [node.material];
                            materials.forEach(material => {
                                material.side = THREE.BackSide;
                                if (material.isMeshStandardMaterial || material.isMeshPhysicalMaterial) {
                                    if (material.userData.initialEmissiveIntensityGLB === undefined) {
                                        material.userData.initialEmissiveIntensityGLB = material.emissiveIntensity;
                                    }
                                    material.emissiveIntensity = material.userData.initialEmissiveIntensityGLB * params.skyboxBrightness;
                                   
                                    if (!material.emissiveMap) {
                                        if (material.userData.initialEmissiveColorGLB === undefined) {
                                            material.userData.initialEmissiveColorGLB = material.emissive.clone();
                                        }
                                        material.emissive.copy(material.userData.initialEmissiveColorGLB).multiplyScalar(params.skyboxBrightness);
                                    }
                                } else if (material.isMeshBasicMaterial) {
                                    if (material.userData.initialColorGLB === undefined) {
                                        material.userData.initialColorGLB = material.color.clone();
                                    }
                                    material.color.copy(material.userData.initialColorGLB).multiplyScalar(params.skyboxBrightness);
                                }
                                material.needsUpdate = true;
                            });
                        }
                    });
                    const skyboxScale = Math.max(camera.far * 0.5, 1000); 
                    skyboxObject.scale.set(skyboxScale, skyboxScale, skyboxScale);
                    skyboxObject.renderOrder = -10; 
                    scene.add(skyboxObject);
                    updateBackgroundVisibility();
                    logToScreen("Skybox GLB berhasil dimuat.");
                },
                undefined, 
                (error) => {
                    logToScreen(`Gagal memuat Skybox GLB dari path: ${params.skyboxGlbUrl}. Error: ${error.message || error}`, "error");
                    if (skyboxObject) {
                        scene.remove(skyboxObject);
                        skyboxObject = null;
                    }
                    updateBackgroundVisibility();
                }
            );
        }

        function updateBackgroundVisibility() {
             if (skyboxObject) {
                skyboxObject.visible = params.showSkybox && !xrSession; 
            }
            if (params.showSkybox && skyboxObject && skyboxObject.children.length > 0 && !xrSession) { 
                 scene.background = null; 
            } else if (!xrSession) { 
                scene.background = new THREE.Color(params.backgroundColor); 
            } else {
                scene.background = null; 
            }
        }

        function applyInitialRotation() {
             if (modelContainerGroup) {
                modelContainerGroup.rotation.set(
                    THREE.MathUtils.degToRad(params.initialRotationX_deg),
                    THREE.MathUtils.degToRad(params.initialRotationY_deg),
                    THREE.MathUtils.degToRad(params.initialRotationZ_deg)
                );
            }
        }
        
        function updateMaterialProperties() {
            if (!model) return;
            model.traverse(node => {
                if (node.isMesh && node.material) {
                    const materials = Array.isArray(node.material) ? node.material : [node.material];
                    materials.forEach(mat => {
                        // mat.side = THREE.DoubleSide; 
                    });
                }
            });
        }

        function frameArea(objectToFrame, cam, ctrl, instant = false, fitOffset = 1.5) {
             if (!objectToFrame || !model) { 
                logToScreen("frameArea: Objek model tidak valid atau belum dimuat.", "warn");
                if (instant) {
                    ctrl.target.set(0,0,0);
                    cam.position.set(0,0.5,3); 
                    ctrl.update();
                }
                return;
            }
        
            const box = new THREE.Box3().setFromObject(objectToFrame);
            const sizeVec = box.getSize(new THREE.Vector3());
            const centerVec = new THREE.Vector3(0,0,0); 

            if (sizeVec.lengthSq() === 0) { 
                 logToScreen("frameArea: Ukuran objek adalah nol.", "warn");
                if (instant) {
                    ctrl.target.copy(centerVec); 
                    cam.position.set(centerVec.x, centerVec.y + 0.5, centerVec.z + 3); 
                    ctrl.update();
                }
                return;
            }

            const maxSize = Math.max(sizeVec.x, sizeVec.y, sizeVec.z);
            const fitHeightDistance = maxSize / (2 * Math.atan(Math.PI * cam.fov / 360));
            const fitWidthDistance = fitHeightDistance / cam.aspect;
            let distance = fitOffset * Math.max(fitHeightDistance, fitWidthDistance);
            distance = Math.max(distance, 0.1); 

            const direction = new THREE.Vector3(0, 0.25, 1).normalize(); 
            
            const targetCamPos = centerVec.clone().add(direction.multiplyScalar(distance));
            
            cam.near = Math.max(0.01, distance / 100);
            cam.far = distance * 100; 
            cam.updateProjectionMatrix();

            ctrl.maxDistance = distance * 10;
            ctrl.minDistance = Math.min(0.01, distance * 0.1);

            if (instant) {
                ctrl.target.copy(centerVec);
                cam.position.copy(targetCamPos);
                cam.lookAt(centerVec);
                ctrl.update();
            } else {
                ctrl.target.copy(centerVec);
                cam.position.copy(targetCamPos);
                cam.lookAt(centerVec);
                ctrl.update(); 
            }
        }

        function goToViewPreset(presetName, instant = false) {
            if (isUpdatingViewPresetGUI) return; 
            
            if (!modelContainerGroup || !camera || !controls || !model ) { 
                logToScreen("goToViewPreset: Komponen belum siap.", "warn");
                return;
            }
            
            isUpdatingViewPresetGUI = true;

            const center = new THREE.Vector3(0,0,0); 
            const currentBox = new THREE.Box3().setFromObject(modelContainerGroup); 
            currentBox.getSize(modelSize);

            const maxDim = Math.max(modelSize.x, modelSize.y, modelSize.z, 0.1); 
            const distanceFactor = 1.8; 
            let distance = maxDim * distanceFactor; 
            distance = Math.max(distance, 0.2);

            let newCamPos = new THREE.Vector3();
            camera.up.set(0,1,0); 

            switch(presetName) {
                case 'Front': newCamPos.set(center.x, center.y, center.z + distance); break;
                case 'Back': newCamPos.set(center.x, center.y, center.z - distance); break;
                case 'Top': newCamPos.set(center.x, center.y + distance, center.z + 0.0001); camera.up.set(0,0,-1); break;
                case 'Bottom': newCamPos.set(center.x, center.y - distance, center.z + 0.0001); camera.up.set(0,0,1); break;
                case 'Left': newCamPos.set(center.x - distance, center.y, center.z); break;
                case 'Right': newCamPos.set(center.x + distance, center.y, center.z); break;
                case 'Default': 
                default:
                    frameArea(modelContainerGroup, camera, controls, instant);
                    params.selectedViewPreset = 'Default'; 
                     if (gui) { 
                        const presetController = gui.controllersRecursive().find(c => c.property === 'selectedViewPreset');
                        if (presetController && presetController.getValue() !== 'Default') {
                             presetController.setValue('Default');
                        } else if (presetController) {
                            presetController.updateDisplay();
                        }
                    }
                    isUpdatingViewPresetGUI = false; 
                    return; 
            }
            
            if (instant) {
                camera.position.copy(newCamPos);
                controls.target.copy(center);
                camera.lookAt(center); 
                controls.update();
            } else {
                camera.position.copy(newCamPos);
                controls.target.copy(center);
                camera.lookAt(center);
                controls.update();
            }

            params.selectedViewPreset = presetName;
            if (gui) { 
                const presetController = gui.controllersRecursive().find(c => c.property === 'selectedViewPreset');
                if (presetController && presetController.getValue() !== presetName) {
                    presetController.setValue(presetName); 
                } else if (presetController) {
                    presetController.updateDisplay();
                }
            }
            isUpdatingViewPresetGUI = false; 
        }

        function setupPresetButtons() {
             const buttons = document.querySelectorAll('.preset-button');
            buttons.forEach(button => {
                button.addEventListener('click', () => {
                    const view = button.getAttribute('data-view');
                    goToViewPreset(view, false); 
                });
            });
        }

        function setupGUI() {
             if (gui) gui.destroy(); 
            gui = new GUI();
            gui.title("Kontrol Model 3D");

            const modelFolder = gui.addFolder('Model');
            modelFolder.add(params, 'modelPath').name('Path Model (.glb)').onFinishChange(value => {
                params.modelPath = value;
                loadMainModel(); 
            });
            modelFolder.add(params, 'modelScale', 0.01, 10, 0.01).name('Skala (Non-AR)').onChange(applyModelScale);
            modelFolder.add(params, 'arModelScale', 0.01, 2.0, 0.005).name('Skala Model AR').onChange(value => { 
                params.arModelScale = value;
                if (xrSession && modelPlaced && modelContainerGroup) { 
                    modelContainerGroup.scale.set(value, value, value);
                    logToScreen(`Skala AR diupdate via GUI menjadi: ${value.toFixed(3)}`);
                } else if (xrSession && !modelPlaced && modelContainerGroup) {
                    modelContainerGroup.scale.set(value, value, value); 
                    logToScreen(`Skala AR pre-placement diupdate via GUI menjadi: ${value.toFixed(3)}`);
                }
            });
            modelFolder.add(params, 'arModelRotationY_deg', -180, 180, 1).name('Rotasi AR Y (derajat)').onChange(value => {
                params.arModelRotationY_deg = value;
                if (xrSession && modelPlaced && modelContainerGroup) {
                    modelContainerGroup.rotation.y = THREE.MathUtils.degToRad(value);
                    logToScreen(`Rotasi AR Y diupdate menjadi: ${value} deg`);
                }
            });
            modelFolder.add(params, 'initialRotationX_deg', -360, 360, 1).name('Rotasi Awal X').onChange(applyInitialRotation);
            modelFolder.add(params, 'initialRotationY_deg', -360, 360, 1).name('Rotasi Awal Y').onChange(applyInitialRotation);
            modelFolder.add(params, 'initialRotationZ_deg', -360, 360, 1).name('Rotasi Awal Z').onChange(applyInitialRotation);
            modelFolder.add(params, 'animateModel').name('Animasi Putar (Non-AR)');
            modelFolder.add(params, 'rotationSpeed', 0, 1, 0.01).name('Kecepatan Putar');
            modelFolder.open();

            const arFolder = gui.addFolder('Pengaturan AR');
            arFolder.add(params, 'showDetectedPlanes').name('Tampilkan Deteksi Bidang').onChange(value => {
                if (!value) { // Jika disembunyikan, hapus semua visualisasi plane
                    detectedPlanes.forEach(planeMesh => scene.remove(planeMesh));
                    detectedPlanes.clear();
                }
                // Jika diaktifkan, visualisasi akan muncul saat plane terdeteksi di animate loop
            });
            arFolder.open();


            const backgroundFolder = gui.addFolder('Latar Belakang (Non-AR)');
            backgroundFolder.add(params, 'showSkybox').name('Tampilkan Skybox').onChange(updateBackgroundVisibility);
            backgroundFolder.add(params, 'skyboxGlbUrl').name('URL Skybox (.glb)').onFinishChange(loadSkyboxFromGLB);
            backgroundFolder.add(params, 'skyboxBrightness', 0, 5, 0.05).name('Kecerahan Skybox').onChange(() => {
                if (skyboxObject) loadSkyboxFromGLB(); 
            });
            backgroundFolder.addColor(params, 'backgroundColor').name('Warna Background').onChange(value => {
                params.backgroundColor = value;
                updateBackgroundVisibility();
            });
            backgroundFolder.open();

            const cameraFolder = gui.addFolder('Kamera & Tampilan (Non-AR)');
            cameraFolder.add(params, 'cameraFOV', 10, 120, 1).name('Field of View (FOV)')
                .onChange(value => {
                    camera.fov = value;
                    camera.updateProjectionMatrix();
                    if (!xrSession) goToViewPreset(params.selectedViewPreset, true); 
                });
            cameraFolder.add(params, 'selectedViewPreset', ['Default', 'Front', 'Back', 'Top', 'Bottom', 'Left', 'Right'])
                .name('Preset Pandangan')
                .onChange(value => { 
                    if (!isUpdatingViewPresetGUI) { 
                        goToViewPreset(value, false); 
                    }
                }); 
            cameraFolder.open();

            const lightingFolder = gui.addFolder('Pencahayaan');
            lightingFolder.add(params, 'ambientLightIntensity', 0, 5, 0.05).name('Intensitas Ambient')
                .onChange(value => { if(ambientLight) ambientLight.intensity = value; });
            lightingFolder.add(params, 'directionalLightIntensity', 0, 5, 0.05).name('Intensitas Directional')
                .onChange(value => { if(directionalLight) directionalLight.intensity = value; });
            lightingFolder.addColor(params, 'directionalLightColor').name('Warna Directional')
                .onChange(value => { if(directionalLight) directionalLight.color.setHex(value); });
            lightingFolder.open();

            const renderingFolder = gui.addFolder('Rendering');
            renderingFolder.add(params, 'toneMappingExposure', 0, 2, 0.01).name('Exposure')
                .onChange(value => { renderer.toneMappingExposure = value; });
            renderingFolder.open();

            const utilitiesFolder = gui.addFolder('Utilitas');
            utilitiesFolder.add({ takeScreenshot: takeScreenshot }, 'takeScreenshot').name('Ambil Screenshot (Non-AR)');
            utilitiesFolder.open();
        }

        function takeScreenshot() {
             try {
                if (xrSession) {
                    logToScreen("Screenshot tidak didukung dalam mode AR.", "warn");
                    return;
                }
                composer.render(); 
                
                const dataURL = renderer.domElement.toDataURL('image/png');
                const a = document.createElement('a');
                a.href = dataURL;
                a.download = `model_view_${Date.now()}.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                logToScreen("Screenshot diambil!");
            } catch (e) {
                logToScreen(`Gagal mengambil screenshot: ${e.message}`, "error");
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            if (model && !xrSession) { 
                 goToViewPreset(params.selectedViewPreset, true);
            }
        }

        function animate(timestamp, frame) { 
            const deltaTime = clock.getDelta();

            if (!xrSession) { 
                controls.update(); 
                if (modelContainerGroup && params.animateModel) {
                    modelContainerGroup.rotation.y += params.rotationSpeed * deltaTime;
                }
                if (skyboxObject && skyboxObject.visible) {
                    skyboxObject.position.copy(camera.position);
                }
                composer.render();
            } else { // Mode AR
                if (frame) {
                    const viewerPose = frame.getViewerPose(renderer.xr.getReferenceSpace());

                    if (viewerPose) {
                        // Handle Plane Detection
                        if (params.showDetectedPlanes && session.detectedPlanes) { // 'detectedPlanes' adalah fitur eksperimental
                            const planes = frame.worldInformation?.detectedPlanes; // Cara baru mendapatkan plane (jika didukung)
                            if (planes) {
                                logToScreen(`Plane terdeteksi: ${planes.size}`, 'info');
                                planes.forEach(plane => {
                                    if (!detectedPlanes.has(plane)) {
                                        logToScreen(`Plane baru terdeteksi: ${plane.orientation}, ID: ${plane.lastChangedTime}`);
                                        const planeGeometry = new THREE.PlaneGeometry(plane.polygon[0].x * 2, plane.polygon[0].z * 2); // Estimasi kasar
                                        const planeMaterial = new THREE.MeshBasicMaterial({
                                            color: 0x00ff00,
                                            transparent: true,
                                            opacity: 0.3,
                                            side: THREE.DoubleSide,
                                            wireframe: true
                                        });
                                        const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
                                        
                                        // Atur posisi dan orientasi planeMesh berdasarkan XRPlane.planeSpace
                                        // Ini memerlukan konversi dari XRSpace ke Three.js world space
                                        // Untuk penyederhanaan, kita letakkan di origin dulu, ini perlu perbaikan
                                        // const planePose = frame.getPose(plane.planeSpace, renderer.xr.getReferenceSpace());
                                        // if(planePose) planeMesh.matrix.fromArray(planePose.transform.matrix);

                                        scene.add(planeMesh);
                                        detectedPlanes.set(plane, planeMesh);
                                    } else {
                                        // Update posisi/orientasi planeMesh jika plane berubah
                                        const planeMesh = detectedPlanes.get(plane);
                                        // const planePose = frame.getPose(plane.planeSpace, renderer.xr.getReferenceSpace());
                                        // if(planePose) planeMesh.matrix.fromArray(planePose.transform.matrix);
                                    }
                                });
                                // Hapus visualisasi untuk plane yang tidak lagi terdeteksi
                                detectedPlanes.forEach((planeMesh, plane) => {
                                    if (!planes.has(plane)) {
                                        scene.remove(planeMesh);
                                        detectedPlanes.delete(plane);
                                    }
                                });
                            }
                        }


                        // Handle Hit-Testing dan Reticle
                        if (xrHitTestSource && !modelPlaced) { 
                            const hitTestResults = frame.getHitTestResults(xrHitTestSource);
                            if (hitTestResults.length > 0) {
                                const hit = hitTestResults[0];
                                const currentRefSpace = renderer.xr.getReferenceSpace(); 
                                if (currentRefSpace) {
                                    const pose = hit.getPose(currentRefSpace);
                                    if (pose) { 
                                        reticleMesh.matrix.fromArray(pose.transform.matrix);
                                        reticleMesh.visible = true; 
                                    } else {
                                        reticleMesh.visible = false;
                                    }
                                } else {
                                     reticleMesh.visible = false;
                                }
                            } else {
                                reticleMesh.visible = false;
                            }
                        } else if (!modelPlaced && !xrHitTestSource && arInstructionsPanel.style.display === 'none') { 
                            reticleMesh.visible = true; 
                            const camWorldPos = new THREE.Vector3();
                            const camWorldDir = new THREE.Vector3();
                            camera.getWorldPosition(camWorldPos);
                            camera.getWorldDirection(camWorldDir);
                            reticleMesh.position.copy(camWorldPos).add(camWorldDir.multiplyScalar(0.7)); 
                            reticleMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), new THREE.Vector3(0,1,0)); 
                            reticleMesh.lookAt(camWorldPos); 
                            reticleMesh.rotation.x = -Math.PI / 2; 
                            reticleMesh.updateMatrix();
                        } else if (modelPlaced) {
                             reticleMesh.visible = false;
                        }
                    }
                }
                renderer.render(scene, camera); 
            }
        }

        init();
    </script>
</body>
</html>
