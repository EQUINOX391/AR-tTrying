<!DOCTYPE html>
<html lang="id">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>3D Model Viewer AR - OLEH FADHILLAH SUKMA ARINI</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet" />
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
          "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.esm.js"
        }
      }
    </script>
    
    <style>
      /* Root Variables for Consistent Styling */
      :root {
        --primary-color: #FFD700; /* Gold Yellow for primary actions */
        --primary-hover: #E6B800; /* Darker Yellow for hover */
        --secondary-color: #34568B; /* Lapis Lazuli Blue for secondary elements */
        --error-color: #f44336; /* Red for errors or active AR stop */
        --surface-dark: rgba(0, 0, 0, 0.8); /* Dark translucent surface */
        --surface-light: rgba(255, 255, 255, 0.1); /* Light translucent surface for buttons */
        --text-primary: #ffffff;
        --text-secondary: rgba(255, 255, 255, 0.8);
        --spacing-unit: 8px;
        --safe-area-inset-bottom: env(safe-area-inset-bottom, 20px);
      }
    
      /* Global Reset and Body Styling */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: 'Plus Jakarta Sans', sans-serif;
        background: linear-gradient(135deg, #1a1a1a, #2c2c2c); /* Dark gradient background */
        color: var(--text-primary);
        overflow: hidden; /* Prevent scrollbars on the body */
        height: 100vh; /* Full viewport height */
        position: relative; /* For positioning fixed children */
      }
      canvas {
        display: block; /* Remove extra space below canvas */
        width: 100%;
        height: 100%;
      }
    
      /* Loading Overlay with Enhanced Icon and Text */
      #loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: #111; /* Solid dark background for loading */
        z-index: 2000; /* Highest z-index to cover everything */
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: calc(var(--spacing-unit) * 2.5); /* Space between elements */
      }
      #loading-overlay .loading-content { /* Wrapper for icon and logo text */
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: calc(var(--spacing-unit) * 1.5); /* Space between icon and text */
      }
      #loading-overlay .logo-icon { /* Styling for the new loading icon */
        font-size: 3.5rem; 
        color: var(--primary-color);
        padding: var(--spacing-unit);
        background-color: rgba(255,255,255,0.05); /* Subtle background */
        border-radius: 50%; /* Circular icon background */
        display: flex;
        align-items: center;
        justify-content: center;
        width: 70px; 
        height: 70px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        animation: pulse 2s infinite alternate; /* New animation */
      }
      @keyframes pulse {
        0% { transform: scale(1); box-shadow: 0 4px 12px rgba(255, 215, 0, 0.2); }
        100% { transform: scale(1.05); box-shadow: 0 8px 20px rgba(255, 215, 0, 0.4); }
      }
      #loading-overlay .logo-text { /* Formerly .logo, for the text part */
        font-size: 1.4rem; /* Adjusted size */
        font-weight: 600;
        letter-spacing: 0.2px;
        padding: calc(var(--spacing-unit) * 1) calc(var(--spacing-unit) * 1.5);
        background: transparent; /* Cleaner look */
        border-radius: 12px;
        text-align: center;
        color: var(--text-primary);
        display: flex;
        flex-direction: column; /* Stack children vertically */
        align-items: center; /* Center them horizontally */
        gap: 5px; /* Small gap between the two lines of text */
      }
      #loading-overlay .logo-text .oleh-text {
        font-size: 1.1rem; /* Slightly smaller for "OLEH" */
        font-weight: 500;
        color: var(--text-secondary); /* A bit subdued */
      }
      #loading-overlay .logo-text .name-text {
        font-size: 1.5rem; /* Slightly larger for the name */
        font-weight: 700;
        color: var(--primary-color); /* Highlight the name with primary color */
      }
      #loading-overlay .spinner {
        border: 6px solid rgba(255, 255, 255, 0.2); /* Slightly thicker border */
        border-top: 6px solid var(--primary-color);
        border-radius: 50%;
        width: 50px; /* Slightly larger spinner */
        height: 50px;
        animation: spin 1s linear infinite;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3); /* Subtle shadow for spinner */
      }
      #loading-overlay .version-loading { /* Version text specific to loading screen */
        font-size: 0.9rem;
        color: var(--text-secondary);
        font-weight: 500;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
    
      /* After 10 seconds, fade out overlay */
      body.loaded #loading-overlay {
        opacity: 0;
        transition: opacity 0.5s ease-out;
        pointer-events: none; /* Allow interaction with elements below */
      }
    
      /* AR Button (Top Right) */
      #ar-button-container {
        position: fixed;
        top: calc(var(--spacing-unit) * 2.5); /* Adjusted spacing */
        right: calc(var(--spacing-unit) * 2.5);
        z-index: 1000;
      }
      #arButton {
        display: flex;
        align-items: center;
        gap: var(--spacing-unit);
        padding: calc(var(--spacing-unit) * 1.25) calc(var(--spacing-unit) * 2); /* Slightly more compact */
        background: var(--primary-color);
        border: none;
        border-radius: 12px; /* Consistent border radius */
        color: #fff;
        font-weight: 600;
        font-size: 0.95rem; /* Slightly smaller font */
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3); /* Yellow shadow */
      }
      #arButton:hover {
        background: var(--primary-hover);
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(255, 215, 0, 0.4); /* Yellow shadow */
      }
      #arButton.ar-active { /* When AR mode is active */
        background: var(--error-color);
        box-shadow: 0 4px 12px rgba(244, 67, 54, 0.3);
      }
      #arButton .material-icons-round {
        font-size: 1.25rem; /* Adjusted icon size */
      }
    
      /* AR Instructions Panel (Center) */
      #ar-instructions {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: var(--surface-dark);
        backdrop-filter: blur(10px); /* Frosted glass effect */
        border-radius: 16px; /* Softer radius */
        padding: calc(var(--spacing-unit) * 2.5); /* Adjusted padding */
        width: calc(100% - var(--spacing-unit) * 5); /* Responsive width with margins */
        max-width: 360px; /* Max width for readability */
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        z-index: 1200; /* Above other UI elements */
        display: none; /* Initially hidden */
        text-align: center;
      }
      #ar-instructions p {
        font-size: 0.95rem; /* Optimized for mobile */
        line-height: 1.6; /* Improved readability */
        margin-bottom: calc(var(--spacing-unit) * 2.5);
      }
      #start-scan-button {
        width: 100%;
        padding: calc(var(--spacing-unit) * 1.75); /* Good tap target size */
        background: var(--primary-color);
        border: none;
        border-radius: 12px;
        color: #fff;
        font-weight: 600;
        font-size: 0.95rem;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex; /* To align icon and text */
        align-items: center;
        justify-content: center;
        gap: var(--spacing-unit);
        box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3); /* Yellow shadow */
      }
      #start-scan-button:hover {
        background: var(--primary-hover);
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(255, 215, 0, 0.4); /* Yellow shadow */
      }
    
      #start-scan-button .material-icons-round {
        font-size: 1.3rem;
      }
    
      /* Bottom Navigation Bar for View Presets (Edge Navbar) */
      .bottom-nav {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(255, 255, 255, 0.15); /* Lighter translucent background */
        backdrop-filter: blur(10px);
        padding: var(--spacing-unit) var(--spacing-unit) calc(var(--spacing-unit) + var(--safe-area-inset-bottom)); /* Adjusted padding for safe area */
        display: flex;
        justify-content: center; /* Center buttons in the row */
        align-items: center; /* Align items if they wrap */
        gap: calc(var(--spacing-unit) * 0.75); /* Reduced gap for compactness */
        z-index: 1000;
        border-top-left-radius: 0; /* Removed top-left radius */
        border-top-right-radius: 0; /* Removed top-right radius */
        box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.2);
        flex-wrap: wrap; /* Allow buttons to wrap on small screens */
      }
      .view-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 3px; /* Reduced gap between icon and text */
        padding: calc(var(--spacing-unit) * 0.75) calc(var(--spacing-unit)); /* More compact padding */
        border-radius: 4px; /* Slightly rounded rectangle */
        border: none;
        background: var(--surface-light);
        color: var(--text-primary);
        font-family: inherit;
        font-weight: 500;
        font-size: 0.65rem; /* Smaller font for compact buttons */
        cursor: pointer;
        transition: all 0.2s ease;
        min-width: 45px; /* Ensure a minimum tap width */
        text-align: center;
      }
      .view-btn:hover {
        background: rgba(255, 255, 255, 0.15);
        transform: translateY(-1px);
      }
      .view-btn .material-icons-round {
        font-size: 1.1rem; /* Smaller icons */
      }

      /* Active state for view buttons */
      .view-btn.active {
        background: var(--primary-color);
        color: #000; /* Black text for active state */
        box-shadow: 0 4px 12px rgba(255, 215, 0, 0.5); /* Stronger yellow shadow */
      }
      .view-btn.active .material-icons-round {
        color: #000; /* Ensure icon is black */
      }
    
      /* On-Screen Log (Positioned above bottom nav) */
      #on-screen-log-container {
        position: fixed;
        /* Calculated to be above the bottom nav: 
           Approx nav height (button + padding) ~70-80px + safe area + margin */
        bottom: calc(80px + var(--safe-area-inset-bottom) + var(--spacing-unit)); 
        left: calc(var(--spacing-unit) * 1.5);
        right: calc(var(--spacing-unit) * 1.5); /* Span more of the width */
        width: auto; /* Let left/right define width */
        max-width: 400px; /* Max width on larger screens if desired */
        margin-left: auto; /* Centering if max-width is hit */
        margin-right: auto; /* Centering if max-width is hit */
        max-height: 90px; /* Reduced height */
        background: rgba(0, 0, 0, 0.7); /* Slightly more opaque */
        color: #ADD8E6; /* Light blue for better contrast */
        font-family: monospace;
        font-size: 0.7rem; /* Smaller log font */
        padding: var(--spacing-unit);
        border-radius: 8px;
        overflow-y: auto;
        z-index: 999; /* Below main controls but above canvas */
        display: none; /* Hidden by default, shown by JS */
        border: 1px solid rgba(255,255,255,0.1); /* Subtle border */
      }
    
      /* App Version Display (Top Left) */
      #app-version {
        position: fixed;
        top: calc(var(--spacing-unit) * 1.5);
        left: calc(var(--spacing-unit) * 2);
        color: var(--text-secondary);
        font-size: 0.75rem; /* Compact size */
        font-weight: 500;
        background-color: rgba(0,0,0,0.4); /* Subtle background for readability */
        padding: calc(var(--spacing-unit) * 0.5) var(--spacing-unit);
        border-radius: 6px;
        z-index: 1001; /* Above AR button container if they were to overlap */
      }

      /* New GUI toggle button styling */
      #gui-toggle-container {
          position: fixed;
          top: calc(var(--spacing-unit) * 2.5); /* Align with AR button's top */
          right: calc(var(--spacing-unit) * 9); /* Position to the left of AR button */
          z-index: 1001;
      }

      #guiToggleButton {
          display: flex;
          align-items: center;
          justify-content: center;
          width: 48px;
          height: 48px;
          background: var(--surface-dark);
          border: none;
          border-radius: 50%; /* Circular button */
          color: var(--text-primary);
          cursor: pointer;
          transition: all 0.2s ease;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      #guiToggleButton:hover {
          background: rgba(255, 255, 255, 0.15);
          transform: translateY(-2px);
          box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
      }

      #guiToggleButton .material-icons-round {
          font-size: 1.5rem;
      }
    
      /* lil-gui (Controls Panel) Overrides - Retained for consistency */
      .lil-gui {
        /* lil-gui manages its own display, so remove 'display: none;' from here */
        --background-color: var(--surface-dark) !important;
        --text-color: var(--text-primary) !important;
        --title-background-color: rgba(0, 0, 0, 0.3) !important;
        --widget-color: var(--surface-light) !important;
        font-family: 'Plus Jakarta Sans', sans-serif !important;
        border-radius: 16px !important;
        overflow: hidden;
        z-index: 1500 !important; /* Ensure it's above other UI but below modals */
      }
      .lil-gui .title {
        font-weight: 600 !important;
        font-size: 0.95rem !important;
      }
      .lil-gui .controller {
        border-radius: 8px !important;
        margin: 4px 0 !important;
      }
    </style>
  </head>
  <body>
    <div id="loading-overlay">
      <div class="loading-content">
        <span class="material-icons-round logo-icon">3d_rotation</span>
        <div class="logo-text">
          <span class="oleh-text">OLEH</span>
          <span class="name-text">FADHILLAH SUKMA ARINI</span>
        </div>
      </div>
      <div class="spinner"></div>
      <div class="version-loading">Version 0.0.5</div>
    </div>
    
    <div id="ar-button-container">
      <button id="arButton">
        <span class="material-icons-round">view_in_ar</span>
        AR Mode
      </button>
    </div>
    
    <div id="ar-instructions">
      <p>Arahkan kamera ke permukaan datar (lantai/meja).</p>
      <button id="start-scan-button">
        <span class="material-icons-round">radar</span>
        Mulai Pindai
      </button>
    </div>
    
    <div id="reticle"></div>
    
    <div id="on-screen-log-container"></div>
    
    <div id="app-version">APP VERSI 0.0.5</div>
    
    <div id="gui-toggle-container">
        <button id="guiToggleButton">
            <span class="material-icons-round">tune</span>
        </button>
    </div>

    <div class="bottom-nav">
      <button class="view-btn" data-view="Default">
        <span class="material-icons-round">restore</span> Default
      </button>
      <button class="view-btn" data-view="Front">
        <span class="material-icons-round">flip_to_front</span> Front
      </button>
      <button class="view-btn" data-view="Back">
        <span class="material-icons-round">flip_to_back</span> Back
      </button>
      <button class="view-btn" data-view="Top">
        <span class="material-icons-round">arrow_upward</span>
        Top
      </button>
      <button class="view-btn" data-view="Bottom">
        <span class="material-icons-round">arrow_downward</span>
        Bottom
      </button>
      <button class="view-btn" data-view="Left">
        <span class="material-icons-round">arrow_back</span> Left
      </button>
      <button class="view-btn" data-view="Right">
        <span class="material-icons-round">arrow_forward</span> Right
      </button>
    </div>
    
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
      import GUI from "lil-gui";
    
      let scene, camera, renderer, controls, composer, gui;
      let model, modelContainerGroup, ambientLight, directionalLight;
      let clock;
      const arInstructionsPanel = document.getElementById("ar-instructions");
      const startScanButton = document.getElementById("start-scan-button");
      const onScreenLogContainer = document.getElementById("on-screen-log-container");
      const appVersionDisplay = document.getElementById("app-version");
    
      let skyboxObject = null;
      const modelCenter = new THREE.Vector3();
      const modelSize = new THREE.Vector3();
    
      let xrSession = null;
      let xrRefSpace = null; // Reference space for AR
      let xrHitTestSource = null;
      let reticleMesh; // The 3D object used as a reticle
      let modelPlaced = false; // Flag to track if the AR model has been placed
    
      let isUpdatingViewPresetGUI = false; // Prevents GUI update loops
    
      const APP_VERSION = "0.0.5"; // App version constant
    
      // AR interaction state variables
      let arIsPinching = false;
      let arInitialPinchDistance = 0;
      let arIsDragging = false;
      let arLastDragX = 0;
      let arLastDragY = 0;
      const arDragSensitivity = 0.005; // How much the model rotates per drag pixel
    
      // Configuration parameters for the viewer
      const params = {
        modelPath: "Cupang.glb", // Default model path
        skyboxGlbUrl: "inside_galaxy_skybox_hdri_360_panorama.glb", // Default skybox
        toneMappingExposure: 1.0,
        ambientLightIntensity: 3.0,
        directionalLightIntensity: 4.0,
        directionalLightColor: 0xffffff,
        initialRotationX_deg: 0.0,
        initialRotationY_deg: 0.0,
        initialRotationZ_deg: 0.0,
        animateModel: false, // Whether the model auto-rotates
        rotationSpeed: 0.1, // Auto-rotation speed
        selectedViewPreset: "Default",
        cameraFOV: 50,
        modelScale: 1.0, // Scale for non-AR mode
        arModelScale: 0.5, // Initial scale for AR mode
        skyboxBrightness: 1.0,
        backgroundColor: "#1A2B3C", // Fallback background color (Dark Blue-Gray)
        showSkybox: true,
      };
    
      // Function to log messages to the on-screen console and browser console
      function logToScreen(message, type = "info") {
        if (onScreenLogContainer) {
          const logEntry = document.createElement("div");
          const timestamp = new Date().toLocaleTimeString();
          logEntry.textContent = `[${timestamp}] ${message}`;
          if (type === "error") logEntry.style.color = "#ff9999"; // Lighter red for dark bg
          else if (type === "warn") logEntry.style.color = "#ffd799"; // Lighter orange
          else logEntry.style.color = "#ADD8E6"; // Light blue
          onScreenLogContainer.appendChild(logEntry);
          onScreenLogContainer.scrollTop = onScreenLogContainer.scrollHeight; // Auto-scroll
        }
        if (type === "error") console.error(message);
        else if (type === "warn") console.warn(message);
        else console.log(message);
      }

      // New function to hide the loading overlay
      function hideLoadingOverlay() {
        const loadingOverlay = document.getElementById("loading-overlay");
        if (loadingOverlay) {
          document.body.classList.add("loaded");
          setTimeout(() => {
            loadingOverlay.remove();
          }, 600); // Match CSS transition time
        }
      }
    
      // Initializes the 3D scene, camera, renderer, and loads initial assets
      function init() {
        clock = new THREE.Clock(); // For animation timing
        scene = new THREE.Scene();
        scene.background = new THREE.Color(params.backgroundColor);
    
        // Setup camera
        camera = new THREE.PerspectiveCamera(
          params.cameraFOV,
          window.innerWidth / window.innerHeight,
          0.01, // Near clipping plane (increased for small AR objects)
          10000 // Far clipping plane
        );
        camera.position.set(0, 1.6, 3); // Default camera position
    
        // Setup renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = params.toneMappingExposure;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.xr.enabled = true; // Enable WebXR
        document.body.appendChild(renderer.domElement);
    
        // Setup orbit controls for non-AR mode
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 0.01; // Allow zooming very close
        controls.maxDistance = 5000;
        controls.target.set(0, 0, 0); // Look at the center of the scene
    
        // Setup lighting
        ambientLight = new THREE.AmbientLight(0xffffff, params.ambientLightIntensity);
        scene.add(ambientLight);
    
        directionalLight = new THREE.DirectionalLight(params.directionalLightColor, params.directionalLightIntensity);
        directionalLight.position.set(1, 1.5, 1).normalize();
        scene.add(directionalLight);
    
        // Group to hold the main model, allowing easy transformation
        modelContainerGroup = new THREE.Group();
        scene.add(modelContainerGroup);
    
        // Setup AR button based on WebXR availability
        const arButtonElement = document.getElementById("arButton");
        if (navigator.xr) {
          navigator.xr
            .isSessionSupported("immersive-ar")
            .then((supported) => {
              arButtonElement.style.display = "flex"; // Show button
              if (supported) {
                arButtonElement.addEventListener("click", onARButtonClick);
                arButtonElement.disabled = false;
                logToScreen("AR didukung oleh perangkat/browser ini.");
              } else {
                if(arButtonElement.childNodes.length > 1 && arButtonElement.childNodes[1].nodeType === Node.TEXT_NODE) {
                    arButtonElement.childNodes[1].textContent = " No AR";
                } else {
                    arButtonElement.insertAdjacentText('beforeend', ' No AR'); // Fallback
                }
                arButtonElement.disabled = true;
                logToScreen("AR tidak didukung oleh perangkat/browser ini.", "warn");
              }
            })
            .catch((err) => {
              logToScreen(`Error saat memeriksa dukungan AR: ${err.message}`, "error");
              if(arButtonElement.childNodes.length > 1 && arButtonElement.childNodes[1].nodeType === Node.TEXT_NODE) {
                  arButtonElement.childNodes[1].textContent = " Err AR";
              } else {
                  arButtonElement.insertAdjacentText('beforeend', ' Err AR');
              }
              arButtonElement.disabled = true;
              arButtonElement.style.display = "flex";
            });
        } else {
          arButtonElement.style.display = "flex";
          if(arButtonElement.childNodes.length > 1 && arButtonElement.childNodes[1].nodeType === Node.TEXT_NODE) {
              arButtonElement.childNodes[1].textContent = " No XR";
          } else {
              arButtonElement.insertAdjacentText('beforeend', ' No XR');
          }
          arButtonElement.disabled = true;
          logToScreen("WebXR API tidak tersedia di browser ini.", "warn");
        }
    
        // Create AR reticle (visual guide for placing objects)
        reticleMesh = new THREE.Mesh(
          new THREE.RingGeometry(0.04, 0.055, 32).rotateX(-Math.PI / 2), // Ring shape, rotated flat
          new THREE.MeshBasicMaterial({ color: 0xFFD700, opacity: 0.8, transparent: true, depthTest: false }) // Gold Yellow, semi-transparent
        );
        reticleMesh.matrixAutoUpdate = false; // Position will be updated manually from hit-test results
        reticleMesh.visible = false; // Initially hidden
        reticleMesh.renderOrder = 10; // Render on top of most things
        scene.add(reticleMesh);
    
        // Load skybox and main model
        if (params.skyboxGlbUrl && params.skyboxGlbUrl !== "SKYBOX_ANDA.glb" && !params.skyboxGlbUrl.includes("placehold.co")) {
          loadSkyboxFromGLB();
        } else {
          logToScreen("Path Skybox GLB tidak valid atau placeholder, skybox tidak akan dimuat secara otomatis.", "warn");
        }
        updateBackgroundVisibility(); // Set initial background/skybox state
        loadMainModel(); // This will now control when the overlay hides.
    
        // Setup post-processing composer (e.g., for effects, though only basic passes here)
        composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);
        const outputPass = new OutputPass(); // Ensures correct output encoding
        composer.addPass(outputPass);
    
        // Initialize GUI controls and preset buttons
        setupGUI();
        setupPresetButtons();
        startScanButton.addEventListener("click", onStartScanButtonClick);
        window.addEventListener("resize", onWindowResize, false);
        // Click listener for placing AR model (now on renderer.domElement for broader capture)
        renderer.domElement.addEventListener("click", onSelectAR); 
        
        // Start the animation loop
        renderer.setAnimationLoop(animate);
        
        // Set initial app version display

        if (appVersionDisplay) appVersionDisplay.textContent = `APP VERSI ${APP_VERSION}`;
      }
    
      // Handles AR button click to start or end an AR session
      function onARButtonClick() {
        const arButtonElement = document.getElementById("arButton");
        const arButtonTextNode = arButtonElement.childNodes.length > 1 && arButtonElement.childNodes[1].nodeType === Node.TEXT_NODE ? arButtonElement.childNodes[1] : arButtonElement.querySelector("span + span") || arButtonElement.appendChild(document.createTextNode("")).previousSibling; 
    
        if (!xrSession) {
          logToScreen("Mencoba memulai sesi AR...");
          navigator.xr
            .requestSession("immersive-ar", {
              requiredFeatures: ["hit-test", "dom-overlay"], // Request hit-testing and DOM overlay
              domOverlay: { root: document.body }, // Specify root for DOM overlay
            })
            .then(onSessionStarted)
            .catch((err) => {
              logToScreen(`Gagal memulai sesi AR: ${err.message}`, "error");
              logToScreen("Pastikan perangkat & browser mendukung AR, dan izin kamera diberikan.", "error");
              if (arButtonTextNode) arButtonTextNode.textContent = " AR Fail";
              arButtonElement.classList.remove("ar-active");
            });
        } else {
          logToScreen("Mengakhiri sesi AR...");
          xrSession.end(); // xrSession.end() will trigger onSessionEnded via event listener
        }
      }
    
      // Called when an AR session successfully starts
      function onSessionStarted(session) {
        logToScreen(`Sesi AR dimulai.`);
        xrSession = session;
        const arButtonElement = document.getElementById("arButton");
        const arButtonTextNode = arButtonElement.childNodes.length > 1 && arButtonElement.childNodes[1].nodeType === Node.TEXT_NODE ? arButtonElement.childNodes[1] : arButtonElement.querySelector("span + span") || arButtonElement.appendChild(document.createTextNode("")).previousSibling; 
    
        if (arButtonTextNode) arButtonTextNode.textContent = " Stop AR";
        arButtonElement.classList.add("ar-active");
    
        // Hide non-AR UI elements
        document.querySelector(".bottom-nav").style.display = "none";
        if (gui) gui.hide();
        if (skyboxObject) skyboxObject.visible = false; // Hide skybox in AR
        scene.background = null; // Transparent background for AR camera feed
    
        // Reset AR state
        xrRefSpace = null;
        xrHitTestSource = null;
        modelPlaced = false;
        if (modelContainerGroup) {
          modelContainerGroup.visible = false; // Hide model until placed
          modelContainerGroup.userData.originalScale = modelContainerGroup.scale.clone(); // Store original scale
          modelContainerGroup.scale.set(params.arModelScale, params.arModelScale, params.arModelScale);
          modelContainerGroup.userData.initialArScale = params.arModelScale; // Store initial AR scale for pinch reference
          logToScreen(`Model disembunyikan, skala AR diatur ke: ${params.arModelScale}`);
        }
        reticleMesh.visible = false; // Hide reticle until scanning starts
        arInstructionsPanel.style.display = "block"; // Show AR placement instructions
        onScreenLogContainer.style.display = "block"; // Show log in AR for debugging
        if (appVersionDisplay) {
            appVersionDisplay.style.display = "block"; // Show app version
            appVersionDisplay.textContent = `APP VERSI ${APP_VERSION}`;
        }
    
        session.addEventListener("end", onSessionEnded); // Handle session end
    
        // Set up reference space and XR session for the renderer
        renderer.xr.setReferenceSpaceType("local"); // 'local' is good for AR experiences where origin is at viewer's start
        renderer.xr
          .setSession(session)
          .then(() => { logToScreen("Sesi XR berhasil diset ke renderer."); })
          .catch((err) => {
            logToScreen(`Error saat set session ke renderer: ${err.message}`, "error");
            session.end().catch((e) => logToScreen(`Error mengakhiri sesi setelah setSession gagal: ${e.message}`, "error"));
          });
      }
    
      // Called when user clicks "Start Scan" in AR instructions
      function onStartScanButtonClick() {
        logToScreen("Tombol 'Mulai Pindai Permukaan' ditekan.");
        arInstructionsPanel.style.display = "none"; // Hide instructions
        if (xrSession && !xrHitTestSource) {
          // Request a 'viewer' reference space to base the hit-test source on
          xrSession.requestReferenceSpace("viewer")
            .then((refSpaceViewer) => {
              logToScreen("Viewer reference space didapatkan untuk hit-test.");
              // Create a hit-test source from the viewer space
              return xrSession.requestHitTestSource({ space: refSpaceViewer });
            })
            .then((source) => {
              xrHitTestSource = source; // Store the hit-test source
              reticleMesh.visible = true; // Show the reticle now that scanning can begin
              logToScreen("Hit test source berhasil didapatkan. Reticle aktif.");
            })
            .catch((err) => {
              logToScreen(`Error mendapatkan hit test source: ${err.message}`, "error");
              logToScreen("Tidak bisa memulai pemindaian permukaan. Coba lagi atau restart sesi AR.", "error");
              reticleMesh.visible = false;
            });
        } else if (xrHitTestSource) {
          logToScreen("Hit test source sudah ada. Reticle seharusnya sudah aktif.");
          reticleMesh.visible = true;
        } else if (!xrSession) {
          logToScreen("Sesi AR tidak aktif saat mencoba memulai pemindaian.", "warn");
        }
      }
    
      // Called when an AR session ends (either by user or programmatically)
      function onSessionEnded() {
        logToScreen("Sesi AR berakhir.");
        if (xrSession) { // Ensure cleanup only if session was active
            xrSession.removeEventListener("end", onSessionEnded); // Clean up event listener
            xrSession = null;
        }
        
        const arButtonElement = document.getElementById("arButton");
        const arButtonTextNode = arButtonElement.childNodes.length > 1 && arButtonElement.childNodes[1].nodeType === Node.TEXT_NODE ? arButtonElement.childNodes[1] : arButtonElement.querySelector("span + span") || arButtonElement.appendChild(document.createTextNode("")).previousSibling; 
    
        if (arButtonTextNode) arButtonTextNode.textContent = " AR Mode";
        arButtonElement.classList.remove("ar-active");
    
        // Restore non-AR UI
        document.querySelector(".bottom-nav").style.display = "flex";
        if (gui) gui.show();
        arInstructionsPanel.style.display = "none";
        onScreenLogContainer.style.display = "none";
        if (appVersionDisplay) appVersionDisplay.style.display = "block"; // Keep version visible or hide as preferred
    
        reticleMesh.visible = false; // Hide reticle
        if (xrHitTestSource) {
            xrHitTestSource.cancel(); // Important: cancel the hit test source
            xrHitTestSource = null;
        }
    
        // Remove AR-specific touch listeners
        renderer.domElement.removeEventListener("touchstart", handleARtouchstart);
        renderer.domElement.removeEventListener("touchmove", handleARtouchmove);
        renderer.domElement.removeEventListener("touchend", handleARtouchend);
        arIsPinching = false;
        arIsDragging = false;
        logToScreen("Listener interaksi AR dihapus.");
    
        // Restore model visibility and scale for non-AR mode
        if (modelContainerGroup) {
          modelContainerGroup.visible = true;
          if (modelContainerGroup.userData.originalScale) {
            modelContainerGroup.scale.copy(modelContainerGroup.userData.originalScale);
            logToScreen(`Skala model dikembalikan ke non-AR: ${modelContainerGroup.scale.x.toFixed(2)}`);
          } else {
            // Fallback if originalScale wasn't set (shouldn't happen in normal flow)
            modelContainerGroup.scale.set(params.modelScale, params.modelScale, params.modelScale);
          }
        }
        // Reset camera to a default view if model exists
        if (model) goToViewPreset('Default', true); // Explicitly set to Default view
        updateBackgroundVisibility(); // Restore skybox/background color
      }
    
      // Handles tap/click in AR mode to place the model
      function onSelectAR(event) {
        logToScreen(
          `onSelectAR. Sesi AR: ${!!xrSession}, Reticle: ${reticleMesh.visible}, Model Ditempatkan: ${modelPlaced}`
        );
        if (xrSession && reticleMesh.visible && !modelPlaced) {
          if (modelContainerGroup && model) {
            logToScreen("Mencoba menempatkan model. Matriks reticle:", reticleMesh.matrix.elements.map((n) => n.toFixed(2)).join(', '));
            // Set model's pose to the reticle's pose
            modelContainerGroup.matrix.copy(reticleMesh.matrix);
            modelContainerGroup.matrix.decompose(modelContainerGroup.position, modelContainerGroup.quaternion, modelContainerGroup.scale); // Apply matrix to position, rotation, scale
            modelContainerGroup.scale.set(params.arModelScale, params.arModelScale, params.arModelScale); // Ensure AR scale is applied
            modelContainerGroup.userData.initialArScale = params.arModelScale; // Re-affirm initial AR scale for interactions
            modelContainerGroup.visible = true; // Make model visible
            modelPlaced = true; // Mark model as placed
            reticleMesh.visible = false; // Hide reticle
            if (xrHitTestSource) { // It's good practice to cancel hit test source once model is placed if not needed further
                // xrHitTestSource.cancel(); // Might re-enable if user wants to move object later
                // xrHitTestSource = null; 
            }
            logToScreen(`Model AR ditempatkan. Pos: ${modelContainerGroup.position.toArray().map((n) => n.toFixed(2))}, Skala: ${params.arModelScale}`);
            
            // Add touch listeners for AR interaction (drag, pinch)
            renderer.domElement.addEventListener("touchstart", handleARtouchstart, { passive: false });
            renderer.domElement.addEventListener("touchmove", handleARtouchmove, { passive: false });
            renderer.domElement.addEventListener("touchend", handleARtouchend, { passive: false });
            logToScreen("Listener interaksi AR (drag/pinch) ditambahkan.");
          } else {
            logToScreen("Model atau modelContainerGroup tidak siap untuk ditempatkan di AR.", "warn");
          }
        } else if (modelPlaced) {
            // If model is already placed, a tap could potentially select it for re-positioning (future feature)
            logToScreen("Model sudah ditempatkan. Tap dideteksi.");
        } else {
          logToScreen("Kondisi untuk menempatkan model AR tidak terpenuhi (reticle tidak terlihat atau sesi AR tidak aktif).");
        }
      }
    
      // --- AR Interaction Functions (Touch for Pinch & Drag) ---
      function getDistanceBetweenTouches(touches) {
        const touch1 = touches[0];
        const touch2 = touches[1];
        return Math.sqrt(Math.pow(touch2.clientX - touch1.clientX, 2) + Math.pow(touch2.clientY - touch1.clientY, 2));
      }
    
      function handleARtouchstart(event) {
        if (!xrSession || !modelPlaced || !modelContainerGroup) return;
        event.preventDefault(); // Prevent default browser actions like scrolling
        const touches = event.touches;
        if (touches.length === 1) { // Single touch: Drag to rotate
          arIsDragging = true;
          arIsPinching = false;
          arLastDragX = touches[0].clientX;
          arLastDragY = touches[0].clientY;
          logToScreen("AR Drag Start");
        } else if (touches.length === 2) { // Two touches: Pinch to scale
          arIsPinching = true;
          arIsDragging = false;
          arInitialPinchDistance = getDistanceBetweenTouches(touches);
          // Store the scale at the beginning of the pinch
          modelContainerGroup.userData.currentPinchStartScale = modelContainerGroup.scale.x; 
          logToScreen(`AR Pinch Start. Initial Distance: ${arInitialPinchDistance.toFixed(2)}, Start Scale: ${modelContainerGroup.userData.currentPinchStartScale.toFixed(3)}`);
        }
      }
    
      function handleARtouchmove(event) {
        if (!xrSession || !modelPlaced || !modelContainerGroup) return;
        event.preventDefault();
        const touches = event.touches;
        if (arIsDragging && touches.length === 1) { // Dragging
          const deltaX = touches[0].clientX - arLastDragX;
          const deltaY = touches[0].clientY - arLastDragY;
          modelContainerGroup.rotation.y += deltaX * arDragSensitivity; // Rotate around Y axis
          modelContainerGroup.rotation.x += deltaY * arDragSensitivity; // Rotate around X axis
          arLastDragX = touches[0].clientX;
          arLastDragY = touches[0].clientY;
        } else if (arIsPinching && touches.length === 2) { // Pinching
          const currentPinchDistance = getDistanceBetweenTouches(touches);
          if (arInitialPinchDistance > 0 && modelContainerGroup.userData.currentPinchStartScale !== undefined) {
            const scaleFactor = currentPinchDistance / arInitialPinchDistance;
            let newScale = modelContainerGroup.userData.currentPinchStartScale * scaleFactor;
            // Clamp scale to reasonable limits
            const minScale = modelContainerGroup.userData.initialArScale * 0.1; // 10% of initial AR scale
            const maxScale = modelContainerGroup.userData.initialArScale * 10; // 1000% of initial AR scale
            newScale = Math.max(minScale, Math.min(newScale, maxScale));
            modelContainerGroup.scale.set(newScale, newScale, newScale);
          }
        }
      }
    
      function handleARtouchend(event) {
        if (!xrSession || !modelPlaced) return;
        // event.preventDefault(); // Not always needed on touchend, but can be for consistency
        if (arIsDragging && event.touches.length < 1) {
          arIsDragging = false;
          logToScreen("AR Drag End");
        }
        if (arIsPinching && event.touches.length < 2) { // If one finger is lifted during pinch
          arIsPinching = false;
          if (modelContainerGroup) {
            // Update the base AR scale param for future GUI interactions or re-pinching
            params.arModelScale = modelContainerGroup.scale.x; 
            if (gui) { // Update GUI if it exists
              const arScaleController = gui.controllersRecursive().find((c) => c.property === "arModelScale");
              if (arScaleController) arScaleController.setValue(params.arModelScale).updateDisplay();
            }
          }
          logToScreen(`AR Pinch End. Final AR Scale: ${params.arModelScale.toFixed(3)}`);
        }
      }
      // --- End AR Interaction Functions ---
    
      // Loads the main 3D model (GLB/GLTF)
      function loadMainModel() {
        logToScreen(`Mulai memuat model dari: ${params.modelPath}`);
        // Clean up previous model if any
        if (model) {
          modelContainerGroup.remove(model);
          model.traverse((node) => { // Dispose geometries and materials
            if (node.geometry) node.geometry.dispose();
            if (node.material) {
              if (Array.isArray(node.material)) node.material.forEach((mat) => mat.dispose());
              else node.material.dispose();
            }
          });
          model = null;
          logToScreen("Model lama dibersihkan.");
        }
        // Reset model transformation trackers
        modelCenter.set(0, 0, 0);
        modelSize.set(0, 0, 0);
        modelContainerGroup.position.set(0, 0, 0);
        modelContainerGroup.rotation.set(0, 0, 0);
        modelContainerGroup.quaternion.identity(); // Reset quaternion
    
        const mainModelLoader = new GLTFLoader();
        mainModelLoader.load(
          params.modelPath,
          function (gltf) { // Success callback
            model = gltf.scene;
            if (!model) {
              logToScreen(`GLTFLoader berhasil, tetapi gltf.scene kosong untuk: ${params.modelPath}`, "error");
              hideLoadingOverlay(); // Hide even if scene is empty but loaded
              return;
            }
            logToScreen("Model GLTF berhasil di-parse.");
            modelContainerGroup.add(model);
    
            // Calculate bounding box and center the model
            const box = new THREE.Box3().setFromObject(modelContainerGroup); // Use modelContainerGroup for correct centering after adding
            box.getCenter(modelCenter); // Get center in world space OF THE GROUP
            box.getSize(modelSize);
            logToScreen(`Ukuran model awal: X:${modelSize.x.toFixed(2)}, Y:${modelSize.y.toFixed(2)}, Z:${modelSize.z.toFixed(2)}`);
            
            // Offset the group so its center is at the world origin (0,0,0)
            // This makes rotations and camera targeting simpler.
            modelContainerGroup.position.sub(modelCenter); 
            modelCenter.set(0,0,0); // Now the logical center of the model (within the group) is (0,0,0)
            logToScreen("ModelContainerGroup dipusatkan ke origin.");
    
            applyInitialRotation(); // Apply user-defined initial rotation
            applyModelScale();     // Apply user-defined scale (handles AR vs non-AR)
            updateMaterialProperties(); // Any custom material tweaks
            logToScreen("Model GLB utama berhasil dimuat dan disiapkan.");
            
            // After model is loaded, set to default view
            goToViewPreset(params.selectedViewPreset, true); 
            hideLoadingOverlay(); // Hide overlay on successful load
          },
          function (xhr) { // Progress callback
            if (xhr.lengthComputable) {
              const percentComplete = (xhr.loaded / xhr.total) * 100;
              console.log(`Memuat Model: ${Math.round(percentComplete, 2)}%`);
            } else {
              console.log(`Memuat Model... (${(xhr.loaded / 1024 / 1024).toFixed(2)} MB)`);
            }
          },
          function (error) { // Error callback
            logToScreen(`Gagal memuat model GLB utama dari: ${params.modelPath}. Error: ${error.message || error}`, "error");
            hideLoadingOverlay(); // Hide overlay even on error, so user can interact
          }
        );
      }
    
      // Applies the current scale parameter to the model
      function applyModelScale() {
        if (modelContainerGroup && model) {
          const scaleValue = xrSession ? params.arModelScale : params.modelScale;
          modelContainerGroup.scale.set(scaleValue, scaleValue, scaleValue);
          logToScreen(`Skala model diatur ke: ${scaleValue.toFixed(3)} (Sesi AR: ${!!xrSession})`);
          
          if (!xrSession) { // Only re-frame if not in AR, as AR placement handles initial view
            const box = new THREE.Box3().setFromObject(modelContainerGroup); // Recalculate size after scaling
            box.getSize(modelSize); // Update modelSize for preset views
            goToViewPreset(params.selectedViewPreset, true); // Re-apply view preset with new scale
          } else {
            // For AR, this scale is the base for pinch-to-zoom
            modelContainerGroup.userData.initialArScale = scaleValue; 
          }
        } else if (!model) {
          logToScreen("applyModelScale dipanggil tetapi model belum dimuat.", "warn");
        }
      }
    
      // Loads a skybox from a GLB file
      function loadSkyboxFromGLB() {
        if (!params.skyboxGlbUrl || params.skyboxGlbUrl === "SKYBOX_ANDA.glb" || params.skyboxGlbUrl.includes("placehold.co")) {
          logToScreen("URL Skybox GLB tidak valid. Skybox tidak akan dimuat.", "warn");
          if (skyboxObject) { // Clean up old skybox if any
            scene.remove(skyboxObject);
            skyboxObject.traverse((node) => { /* dispose geometry/material */ });
            skyboxObject = null;
          }
          updateBackgroundVisibility(); // Fallback to color
          return;
        }
        logToScreen(`Mulai memuat skybox dari: ${params.skyboxGlbUrl}`);
        const loader = new GLTFLoader();
        loader.load(
          params.skyboxGlbUrl,
          (gltf) => { // Success
            if (skyboxObject) { // Clean up previous skybox
              scene.remove(skyboxObject);
              skyboxObject.traverse((node) => { 
                if (node.geometry) node.geometry.dispose();
                if (node.material) {
                  if (Array.isArray(node.material)) node.material.forEach((mat) => mat.dispose());
                  else node.material.dispose();
                }
              });
            }
            skyboxObject = gltf.scene;
            skyboxObject.traverse((node) => { // Ensure skybox material properties are correct
              if (node.isMesh) {
                const materials = Array.isArray(node.material) ? node.material : [node.material];
                materials.forEach((material) => {
                  material.side = THREE.BackSide; // Render inside of the skybox
                  // Adjust brightness based on params.skyboxBrightness
                  if (material.isMeshStandardMaterial || material.isMeshPhysicalMaterial) {
                    if (material.userData.initialEmissiveIntensityGLB === undefined) {
                        material.userData.initialEmissiveIntensityGLB = material.emissiveIntensity !== undefined ? material.emissiveIntensity : 1; // Default to 1 if not set
                    }
                    material.emissiveIntensity = material.userData.initialEmissiveIntensityGLB * params.skyboxBrightness;
                    if (!material.emissiveMap) { // If no emissive map, tint the emissive color
                        if (material.userData.initialEmissiveColorGLB === undefined) {
                            material.userData.initialEmissiveColorGLB = material.emissive ? material.emissive.clone() : new THREE.Color(0xffffff); // Default to white
                        }
                        material.emissive.copy(material.userData.initialEmissiveColorGLB).multiplyScalar(params.skyboxBrightness);
                    }
                  } else if (material.isMeshBasicMaterial) { // For basic materials, adjust color
                    if (material.userData.initialColorGLB === undefined) {
                        material.userData.initialColorGLB = material.color ? material.color.clone() : new THREE.Color(0xffffff);
                    }
                    material.color.copy(material.userData.initialColorGLB).multiplyScalar(params.skyboxBrightness);
                  }
                  material.needsUpdate = true;
                });
              }
            });
            // Scale skybox to be very large
            const skyboxScale = Math.max(camera.far * 0.5, 1000); // Ensure it's beyond far plane or at least 1000 units
            skyboxObject.scale.set(skyboxScale, skyboxScale, skyboxScale);
            skyboxObject.renderOrder = -10; // Render behind everything else
            scene.add(skyboxObject);
            updateBackgroundVisibility(); // Apply visibility based on params
            logToScreen("Skybox GLB berhasil dimuat.");
          },
          undefined, // Progress callback (optional)
          (error) => { // Error callback
            logToScreen(`Gagal memuat Skybox GLB: ${params.skyboxGlbUrl}. Error: ${error.message || error}`, "error");
            if (skyboxObject) { scene.remove(skyboxObject); skyboxObject = null; }
            updateBackgroundVisibility(); // Fallback to color
          }
        );
      }
    
      // Updates visibility of skybox vs. solid background color
      function updateBackgroundVisibility() {
        if (skyboxObject) {
          skyboxObject.visible = params.showSkybox && !xrSession; // Skybox visible if toggled and not in AR
        }
        if (params.showSkybox && skyboxObject && skyboxObject.children.length > 0 && !xrSession) {
          scene.background = null; // Use skybox if available and shown
        } else if (!xrSession) { // Not in AR, use background color
          scene.background = new THREE.Color(params.backgroundColor);
        } else { // In AR, background should be transparent (camera feed)
          scene.background = null;
        }
      }
    
      // Applies initial rotation from params to the model
      function applyInitialRotation() {
        if (modelContainerGroup) {
          modelContainerGroup.rotation.set(
            THREE.MathUtils.degToRad(params.initialRotationX_deg),
            THREE.MathUtils.degToRad(params.initialRotationY_deg),
            THREE.MathUtils.degToRad(params.initialRotationZ_deg)
          );
        }
      }
    
      // Placeholder for any custom material updates needed on the model
      function updateMaterialProperties() {
        if (!model) return;
        model.traverse((node) => {
          if (node.isMesh && node.material) {
            // Example: node.material.roughness = 0.5;
            // This function can be expanded to tweak materials after loading
          }
        });
      }
    
      // Moves camera to a predefined view preset 
      function goToViewPreset(presetName, instant = false) {
        if (isUpdatingViewPresetGUI) return; // Prevent recursion if called from GUI change
        if (!modelContainerGroup || !camera || !controls || !model) {
          logToScreen("goToViewPreset: Komponen belum siap (model, kamera, atau kontrol).", "warn");
          return;
        }
        isUpdatingViewPresetGUI = true; // Flag to prevent GUI feedback loop
    
        const center = new THREE.Vector3(); // Model is centered at origin within its group
        // Recalculate bounding box of the *visible model parts* within the container group
        const currentBox = new THREE.Box3();
        model.traverseVisible(obj => { // Only consider visible parts of the model itself
            if(obj.isMesh) currentBox.expandByObject(obj);
        });
        currentBox.getSize(modelSize); // Get size of the actual model meshes
        // Apply current group scale to the modelSize
        modelSize.multiply(modelContainerGroup.scale);
    
        const maxDim = Math.max(modelSize.x, modelSize.y, modelSize.z, 0.1); // Ensure non-zero
        const distanceFactor = 2.0; // How far to place camera relative to model size
        let distance = maxDim * distanceFactor;
        distance = Math.max(distance, 0.2); // Minimum distance
    
        let newCamPos = new THREE.Vector3();
        camera.up.set(0, 1, 0); // Default UP vector
    
        switch (presetName) {
          case "Front": // User: "dari kiri" -> camera on negative X
            newCamPos.set(center.x - distance, center.y, center.z);
            break;
          case "Back": // User: "dari kanan" -> camera on positive X
            newCamPos.set(center.x + distance, center.y, center.z);
            break;
          case "Left": // User: "dari depan" -> camera on positive Z
            newCamPos.set(center.x, center.y, center.z + distance);
            break;
          case "Right": // User: "dari belakang" -> camera on negative Z
            newCamPos.set(center.x, center.y, center.z - distance);
            break;
          case "Top":
            newCamPos.set(center.x, center.y + distance, center.z + 0.0001); // Slight Z offset for lookAt
            camera.up.set(0, 0, -1); // When looking from top, Z is "up" on screen if model is Y-up
            break;
          case "Bottom":
            newCamPos.set(center.x, center.y - distance, center.z + 0.0001);
            camera.up.set(0, 0, 1); // When looking from bottom
            break;
          case "Default":
          default:
            // Reset model's position, rotation, and scale to initial parameters
            modelContainerGroup.position.set(0, 0, 0);
            modelContainerGroup.rotation.set(
              THREE.MathUtils.degToRad(params.initialRotationX_deg),
              THREE.MathUtils.degToRad(params.initialRotationY_deg),
              THREE.MathUtils.degToRad(params.initialRotationZ_deg)
            );
            modelContainerGroup.scale.set(params.modelScale, params.modelScale, params.modelScale);

            // Reset camera to its initial load position and target
            camera.position.set(0, 1.6, 3);
            controls.target.set(0, 0, 0);
            camera.up.set(0, 1, 0); // Ensure camera up is reset
            controls.update(); // Update controls to reflect changes
            
            params.selectedViewPreset = "Default";
            if (gui) {
              const presetController = gui.controllersRecursive().find((c) => c.property === "selectedViewPreset");
              if (presetController && presetController.getValue() !== "Default") {
                presetController.setValue("Default").updateDisplay();
              } else if (presetController) {
                presetController.updateDisplay();
              }
            }
            isUpdatingViewPresetGUI = false;
            // Update active button state
            updateActiveButton(presetName);
            return;
        }
    
        // Apply new camera position and update controls
        if (instant) {
          camera.position.copy(newCamPos);
          controls.target.copy(center);
          camera.lookAt(center); // Ensure camera looks at the center
          controls.update(); // Crucial for orbit controls to sync
        } else {
          // For smooth transition (not implemented here, would need GSAP or similar tweening)
          // For now, "non-instant" is also instant.
          camera.position.copy(newCamPos);
          controls.target.copy(center);
          camera.lookAt(center);
          controls.update();
        }
    
        params.selectedViewPreset = presetName; // Update current preset param
        if (gui) { // Update GUI dropdown
          const presetController = gui.controllersRecursive().find((c) => c.property === "selectedViewPreset");
          if (presetController && presetController.getValue() !== presetName) {
            presetController.setValue(presetName).updateDisplay();
          } else if (presetController) {
            presetController.updateDisplay(); // Just refresh if value is already correct
          }
        }
        isUpdatingViewPresetGUI = false;
        // Update active button state
        updateActiveButton(presetName);
      }
    
      // Utility to frame an object in camera view
      function frameArea(objectToFrame, cam, ctrl, instant = false, fitOffset = 1.5) {
        if (!objectToFrame || !model) { // Check if model exists within objectToFrame
          logToScreen("frameArea: Objek model tidak valid atau belum dimuat.", "warn");
          if (instant) { // Fallback camera position
            ctrl.target.set(0, 0, 0);
            cam.position.set(0, 0.5, 3); // Default fallback
            ctrl.update();
          }
          return;
        }
    
        const box = new THREE.Box3();
        // Important: get bounding box of the *model itself*, not necessarily the container group if it's empty or has other things.
        // However, the container group IS what we want to frame if it's correctly centered.
        // Let's assume objectToFrame (modelContainerGroup) is what needs to be framed and is centered.
        box.setFromObject(objectToFrame); 
    
        const sizeVec = box.getSize(new THREE.Vector3());
        const centerVec = box.getCenter(new THREE.Vector3()); // Center of the object to frame
    
        if (sizeVec.lengthSq() === 0) { // Handle empty or zero-size objects
          logToScreen("frameArea: Ukuran objek adalah nol.", "warn");
          if (instant) {
            ctrl.target.copy(centerVec); // Target the (potentially non-origin) center
            cam.position.set(centerVec.x, centerVec.y + 0.5, centerVec.z + 3);
            ctrl.update();
          }
          return;
        }
    
        const maxSize = Math.max(sizeVec.x, sizeVec.y, sizeVec.z);
        const fitHeightDistance = maxSize / (2 * Math.atan((Math.PI * cam.fov) / 360));
        const fitWidthDistance = fitHeightDistance / cam.aspect;
        let distance = fitOffset * Math.max(fitHeightDistance, fitWidthDistance);
        distance = Math.max(distance, 0.1); // Ensure minimum distance
    
        // Position camera slightly offset and looking at the object's center
        const direction = cam.position.clone().sub(centerVec).normalize().multiplyScalar(distance);
        const targetCamPos = centerVec.clone().add(direction);
    
        // If camera is already at center (e.g. (0,0,0)), set a default direction
        if (direction.lengthSq() < 0.001) {
            targetCamPos.set(centerVec.x, centerVec.y + sizeVec.y * 0.5, centerVec.z + distance); // Default view slightly above and back
        }
    
        // Adjust near/far planes based on new distance for better depth precision
        cam.near = Math.max(0.01, distance / 100);
        cam.far = distance * 100;
        cam.updateProjectionMatrix();
    
        // Update OrbitControls limits
        ctrl.maxDistance = distance * 10;
        ctrl.minDistance = Math.min(0.01, distance * 0.1); // Allow closer zoom
    
        if (instant) {
          ctrl.target.copy(centerVec);
          cam.position.copy(targetCamPos);
          cam.lookAt(centerVec); // Ensure it looks at the center
          ctrl.update();
        } else { // Smooth transition (currently also instant)
          ctrl.target.copy(centerVec);
          cam.position.copy(targetCamPos);
          cam.lookAt(centerVec);
          ctrl.update();
        }
      }

      // Function to update the active state of view buttons
      function updateActiveButton(activeView) {
        const buttons = document.querySelectorAll(".view-btn");
        buttons.forEach(button => {
          if (button.getAttribute("data-view") === activeView) {
            button.classList.add("active");
          } else {
            button.classList.remove("active");
          }
        });
      }
    
      // Sets up event listeners for the preset view buttons
      function setupPresetButtons() {
        const buttons = document.querySelectorAll(".view-btn");
        buttons.forEach((button) => {
          button.addEventListener("click", () => {
            const view = button.getAttribute("data-view");
            goToViewPreset(view, false); // Use non-instant for button clicks if smooth transition is ever added
          });
        });
        // Set Default button as active on initial load
        updateActiveButton(params.selectedViewPreset);
      }
    
      // Sets up the lil-gui panel for controlling parameters
      function setupGUI() {
        if (gui) gui.destroy(); // Destroy old GUI if exists
        gui = new GUI();
        gui.title("Kontrol Model 3D"); // Title remains for internal GUI structure
        
        // Lil-gui creates its own DOM element. We need to explicitly hide it after creation.
        // The CSS rule for .lil-gui should NOT have display: none;
        gui.domElement.style.display = 'none'; // Hide it initially via JS

        const guiToggleButton = document.getElementById('guiToggleButton');
        const guiToggleButtonIcon = guiToggleButton.querySelector('.material-icons-round');

        guiToggleButton.addEventListener('click', () => {
            if (gui.domElement.style.display === 'none') { // Check current display style
                gui.show();
                guiToggleButtonIcon.textContent = 'close'; 
                logToScreen("Panel Kontrol Model 3D dibuka.");
            } else {
                gui.hide();
                guiToggleButtonIcon.textContent = 'tune';
                logToScreen("Panel Kontrol Model 3D ditutup.");
            }
        });
    
        const modelFolder = gui.addFolder("Model");
        modelFolder.add(params, "modelPath").name("Path Model (.glb)").onFinishChange((value) => {
          params.modelPath = value; loadMainModel();
        });
        modelFolder.add(params, "modelScale", 0.01, 10, 0.01).name("Skala (Non-AR)").onChange(applyModelScale);
        modelFolder.add(params, "arModelScale", 0.01, 5.0, 0.005).name("Skala Model AR")
          .onChange((value) => {
            params.arModelScale = value;
            if (xrSession && modelPlaced && modelContainerGroup) { // If AR model is already placed
              modelContainerGroup.scale.set(value, value, value);
              logToScreen(`Skala AR diupdate via GUI menjadi: ${value.toFixed(3)}`);
            } else if (xrSession && !modelPlaced && modelContainerGroup) { // If AR active but model not yet placed
              modelContainerGroup.scale.set(value, value, value); // This will be its initial placed scale
              logToScreen(`Skala AR pre-placement diupdate via GUI menjadi: ${value.toFixed(3)}`);
            }
          });
        modelFolder.add(params, "initialRotationX_deg", -360, 360, 1).name("Rotasi Awal X").onChange(applyInitialRotation);
        modelFolder.add(params, "initialRotationY_deg", -360, 360, 1).name("Rotasi Awal Y").onChange(applyInitialRotation);
        modelFolder.add(params, "initialRotationZ_deg", -360, 360, 1).name("Rotasi Awal Z").onChange(applyInitialRotation);
        modelFolder.add(params, "animateModel").name("Animasi Putar (Non-AR)");
        modelFolder.add(params, "rotationSpeed", 0, 1, 0.01).name("Kecepatan Putar");
        modelFolder.open();
    
        const backgroundFolder = gui.addFolder("Latar Belakang (Non-AR)");
        backgroundFolder.add(params, "showSkybox").name("Tampilkan Skybox").onChange(updateBackgroundVisibility);
        backgroundFolder.add(params, "skyboxGlbUrl").name("URL Skybox (.glb)").onFinishChange(loadSkyboxFromGLB);
        backgroundFolder.add(params, "skyboxBrightness", 0, 5, 0.05).name("Kecerahan Skybox")
          .onChange(() => { if (skyboxObject) loadSkyboxFromGLB(); }); // Reload skybox to apply brightness
        backgroundFolder.addColor(params, "backgroundColor").name("Warna Background").onChange((value) => {
          params.backgroundColor = value; updateBackgroundVisibility();
        });
        backgroundFolder.open();
    
        const cameraFolder = gui.addFolder("Kamera & Tampilan (Non-AR)");
        cameraFolder.add(params, "cameraFOV", 10, 120, 1).name("Field of View (FOV)").onChange((value) => {
          camera.fov = value;
          camera.updateProjectionMatrix();
          if (!xrSession) goToViewPreset(params.selectedViewPreset, true); // Re-frame with new FOV
        });
        cameraFolder.add(params, "selectedViewPreset", ["Default", "Front", "Back", "Top", "Bottom", "Left", "Right"])
          .name("Preset Pandangan").onChange((value) => {
            if (!isUpdatingViewPresetGUI) goToViewPreset(value, false); // Call if not already being updated
          });
        cameraFolder.open();
    
        const lightingFolder = gui.addFolder("Pencahayaan");
        lightingFolder.add(params, "ambientLightIntensity", 0, 5, 0.05).name("Intensitas Ambient")
          .onChange((value) => { if (ambientLight) ambientLight.intensity = value; });
        lightingFolder.add(params, "directionalLightIntensity", 0, 5, 0.05).name("Intensitas Directional")
          .onChange((value) => { if (directionalLight) directionalLight.intensity = value; });
        lightingFolder.addColor(params, "directionalLightColor").name("Warna Directional")
          .onChange((value) => { if (directionalLight) directionalLight.color.setHex(value); });
        lightingFolder.open();
    
        const renderingFolder = gui.addFolder("Rendering");
        renderingFolder.add(params, "toneMappingExposure", 0, 2, 0.01).name("Exposure")
          .onChange((value) => { renderer.toneMappingExposure = value; });
        renderingFolder.open();
        
        const utilitiesFolder = gui.addFolder("Utilitas");
        utilitiesFolder.add({ takeScreenshot: takeScreenshot }, "takeScreenshot").name("Ambil Screenshot (Non-AR)");
        utilitiesFolder.open();
      }
    
      // Takes a screenshot of the current view (non-AR mode)
      function takeScreenshot() {
        try {
          if (xrSession) {
            logToScreen("Screenshot tidak didukung dalam mode AR.", "warn");
            return;
          }
          composer.render(); // Ensure scene is rendered with post-processing if any
          const dataURL = renderer.domElement.toDataURL("image/png");
          const a = document.createElement("a");
          a.href = dataURL;
          a.download = `model_view_${Date.now()}.png`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          logToScreen("Screenshot diambil!");
        } catch (e) {
          logToScreen(`Gagal mengambil screenshot: ${e.message}`, "error");
        }
      }
    
      // Handles window resize events to update camera and renderer
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight); // Update composer size
        if (model && !xrSession) goToViewPreset(params.selectedViewPreset, true); // Re-frame on resize
      }
    
      // Main animation loop, called every frame by the renderer
      function animate(timestamp, frame) { // timestamp and frame are provided by WebXR
        const deltaTime = clock.getDelta(); // Time since last frame
    
        if (!xrSession) { // Non-AR mode
          controls.update(); // Update orbit controls
          if (modelContainerGroup && params.animateModel) { // Auto-rotate model if enabled
            modelContainerGroup.rotation.y += params.rotationSpeed * deltaTime;
          }
          if (skyboxObject && skyboxObject.visible) { // Keep skybox centered on camera
            skyboxObject.position.copy(camera.position);
          }
          composer.render(); // Render scene via composer
        } else { // AR mode
          if (frame) { // If an XRFrame is available
            const currentRefSpace = renderer.xr.getReferenceSpace(); // Get current reference space
            if (xrHitTestSource && !modelPlaced && reticleMesh && currentRefSpace) {
              const hitTestResults = frame.getHitTestResults(xrHitTestSource); // Perform hit-test
              if (hitTestResults.length > 0) {
                const hit = hitTestResults[0];
                const pose = hit.getPose(currentRefSpace); // Get pose of the hit in current ref space
                if (pose) {
                  reticleMesh.matrix.fromArray(pose.transform.matrix); // Update reticle pose
                  reticleMesh.visible = true;
                } else { reticleMesh.visible = false; }
              } else { reticleMesh.visible = false; } // No hits, hide reticle
            } else if (!modelPlaced && !xrHitTestSource && arInstructionsPanel.style.display === "none" && reticleMesh) {
              // Fallback reticle positioning if hit-test isn't active (e.g., before scanning starts but instructions are hidden)
              // This might not be ideal UX, usually reticle appears only with active hit-test.
              // For now, keeping original logic for this case.
              reticleMesh.visible = true; 
              const camWorldPos = new THREE.Vector3();
              const camWorldDir = new THREE.Vector3();
              camera.getWorldPosition(camWorldPos);
              camera.getWorldDirection(camWorldDir);
              reticleMesh.position.copy(camWorldPos).add(camWorldDir.multiplyScalar(0.7)); // Place 0.7m in front of camera
              reticleMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0)); // Align Y up
              reticleMesh.lookAt(camWorldPos); // Look towards camera (makes it flat)
              reticleMesh.rotation.x = -Math.PI / 2; // Rotate to be flat on ground
              reticleMesh.updateMatrix();
            } else if (modelPlaced) { // If model is placed, reticle should be hidden
              if (reticleMesh) reticleMesh.visible = false;
            }
          }
          renderer.render(scene, camera); // Render AR scene directly (composer might not be used in AR)
        }
      }
    
      // Start the application
      init();
    </script>
  </body>
</html>
